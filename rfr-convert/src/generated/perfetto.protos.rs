// This file is @generated by prost-build.
/// Describes the attributes for a Chrome process. Must be paired with a
/// ProcessDescriptor in the same TrackDescriptor.
///
/// Next id: 6.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeProcessDescriptor {
    #[prost(enumeration = "chrome_process_descriptor::ProcessType", optional, tag = "1")]
    pub process_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub process_priority: ::core::option::Option<i32>,
    /// To support old UI. New UI should determine default sorting by process_type.
    #[prost(int32, optional, tag = "3")]
    pub legacy_sort_index: ::core::option::Option<i32>,
    /// Name of the hosting app for WebView. Used to match renderer processes to
    /// their hosting apps.
    #[prost(string, optional, tag = "4")]
    pub host_app_package_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The ID to link crashes to trace.
    /// Notes:
    /// * The ID is per process. So, each trace may contain many IDs, and you need
    ///    to look for the ID from crashed process to find the crash report.
    /// * Having a "chrome-trace-id" in crash doesn't necessarily mean we can
    ///    get an uploaded trace, since uploads could have failed.
    /// * On the other hand, if there was a crash during the session and trace was
    ///    uploaded, it is very likely to find a crash report with the trace ID.
    /// * This is not crash ID or trace ID. It is just a random 64-bit number
    ///    recorded in both traces and crashes. It is possible to have collisions,
    ///    though very rare.
    #[prost(uint64, optional, tag = "5")]
    pub crash_trace_id: ::core::option::Option<u64>,
}
/// Nested message and enum types in `ChromeProcessDescriptor`.
pub mod chrome_process_descriptor {
    /// See chromium's content::ProcessType.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProcessType {
        ProcessUnspecified = 0,
        ProcessBrowser = 1,
        ProcessRenderer = 2,
        ProcessUtility = 3,
        ProcessZygote = 4,
        ProcessSandboxHelper = 5,
        ProcessGpu = 6,
        ProcessPpapiPlugin = 7,
        ProcessPpapiBroker = 8,
        ProcessServiceNetwork = 9,
        ProcessServiceTracing = 10,
        ProcessServiceStorage = 11,
        ProcessServiceAudio = 12,
        ProcessServiceDataDecoder = 13,
        ProcessServiceUtilWin = 14,
        ProcessServiceProxyResolver = 15,
        ProcessServiceCdm = 16,
        ProcessServiceVideoCapture = 17,
        ProcessServiceUnzipper = 18,
        ProcessServiceMirroring = 19,
        ProcessServiceFilepatcher = 20,
        ProcessServiceTts = 21,
        ProcessServicePrinting = 22,
        ProcessServiceQuarantine = 23,
        ProcessServiceCrosLocalsearch = 24,
        ProcessServiceCrosAssistantAudioDecoder = 25,
        ProcessServiceFileutil = 26,
        ProcessServicePrintcompositor = 27,
        ProcessServicePaintpreview = 28,
        ProcessServiceSpeechrecognition = 29,
        ProcessServiceXrdevice = 30,
        ProcessServiceReadicon = 31,
        ProcessServiceLanguagedetection = 32,
        ProcessServiceSharing = 33,
        ProcessServiceMediaparser = 34,
        ProcessServiceQrcodegenerator = 35,
        ProcessServiceProfileimport = 36,
        ProcessServiceIme = 37,
        ProcessServiceRecording = 38,
        ProcessServiceShapedetection = 39,
        ProcessRendererExtension = 40,
        ProcessServiceMediaFoundation = 41,
    }
    impl ProcessType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ProcessUnspecified => "PROCESS_UNSPECIFIED",
                Self::ProcessBrowser => "PROCESS_BROWSER",
                Self::ProcessRenderer => "PROCESS_RENDERER",
                Self::ProcessUtility => "PROCESS_UTILITY",
                Self::ProcessZygote => "PROCESS_ZYGOTE",
                Self::ProcessSandboxHelper => "PROCESS_SANDBOX_HELPER",
                Self::ProcessGpu => "PROCESS_GPU",
                Self::ProcessPpapiPlugin => "PROCESS_PPAPI_PLUGIN",
                Self::ProcessPpapiBroker => "PROCESS_PPAPI_BROKER",
                Self::ProcessServiceNetwork => "PROCESS_SERVICE_NETWORK",
                Self::ProcessServiceTracing => "PROCESS_SERVICE_TRACING",
                Self::ProcessServiceStorage => "PROCESS_SERVICE_STORAGE",
                Self::ProcessServiceAudio => "PROCESS_SERVICE_AUDIO",
                Self::ProcessServiceDataDecoder => "PROCESS_SERVICE_DATA_DECODER",
                Self::ProcessServiceUtilWin => "PROCESS_SERVICE_UTIL_WIN",
                Self::ProcessServiceProxyResolver => "PROCESS_SERVICE_PROXY_RESOLVER",
                Self::ProcessServiceCdm => "PROCESS_SERVICE_CDM",
                Self::ProcessServiceVideoCapture => "PROCESS_SERVICE_VIDEO_CAPTURE",
                Self::ProcessServiceUnzipper => "PROCESS_SERVICE_UNZIPPER",
                Self::ProcessServiceMirroring => "PROCESS_SERVICE_MIRRORING",
                Self::ProcessServiceFilepatcher => "PROCESS_SERVICE_FILEPATCHER",
                Self::ProcessServiceTts => "PROCESS_SERVICE_TTS",
                Self::ProcessServicePrinting => "PROCESS_SERVICE_PRINTING",
                Self::ProcessServiceQuarantine => "PROCESS_SERVICE_QUARANTINE",
                Self::ProcessServiceCrosLocalsearch => "PROCESS_SERVICE_CROS_LOCALSEARCH",
                Self::ProcessServiceCrosAssistantAudioDecoder => {
                    "PROCESS_SERVICE_CROS_ASSISTANT_AUDIO_DECODER"
                }
                Self::ProcessServiceFileutil => "PROCESS_SERVICE_FILEUTIL",
                Self::ProcessServicePrintcompositor => "PROCESS_SERVICE_PRINTCOMPOSITOR",
                Self::ProcessServicePaintpreview => "PROCESS_SERVICE_PAINTPREVIEW",
                Self::ProcessServiceSpeechrecognition => {
                    "PROCESS_SERVICE_SPEECHRECOGNITION"
                }
                Self::ProcessServiceXrdevice => "PROCESS_SERVICE_XRDEVICE",
                Self::ProcessServiceReadicon => "PROCESS_SERVICE_READICON",
                Self::ProcessServiceLanguagedetection => {
                    "PROCESS_SERVICE_LANGUAGEDETECTION"
                }
                Self::ProcessServiceSharing => "PROCESS_SERVICE_SHARING",
                Self::ProcessServiceMediaparser => "PROCESS_SERVICE_MEDIAPARSER",
                Self::ProcessServiceQrcodegenerator => "PROCESS_SERVICE_QRCODEGENERATOR",
                Self::ProcessServiceProfileimport => "PROCESS_SERVICE_PROFILEIMPORT",
                Self::ProcessServiceIme => "PROCESS_SERVICE_IME",
                Self::ProcessServiceRecording => "PROCESS_SERVICE_RECORDING",
                Self::ProcessServiceShapedetection => "PROCESS_SERVICE_SHAPEDETECTION",
                Self::ProcessRendererExtension => "PROCESS_RENDERER_EXTENSION",
                Self::ProcessServiceMediaFoundation => "PROCESS_SERVICE_MEDIA_FOUNDATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROCESS_UNSPECIFIED" => Some(Self::ProcessUnspecified),
                "PROCESS_BROWSER" => Some(Self::ProcessBrowser),
                "PROCESS_RENDERER" => Some(Self::ProcessRenderer),
                "PROCESS_UTILITY" => Some(Self::ProcessUtility),
                "PROCESS_ZYGOTE" => Some(Self::ProcessZygote),
                "PROCESS_SANDBOX_HELPER" => Some(Self::ProcessSandboxHelper),
                "PROCESS_GPU" => Some(Self::ProcessGpu),
                "PROCESS_PPAPI_PLUGIN" => Some(Self::ProcessPpapiPlugin),
                "PROCESS_PPAPI_BROKER" => Some(Self::ProcessPpapiBroker),
                "PROCESS_SERVICE_NETWORK" => Some(Self::ProcessServiceNetwork),
                "PROCESS_SERVICE_TRACING" => Some(Self::ProcessServiceTracing),
                "PROCESS_SERVICE_STORAGE" => Some(Self::ProcessServiceStorage),
                "PROCESS_SERVICE_AUDIO" => Some(Self::ProcessServiceAudio),
                "PROCESS_SERVICE_DATA_DECODER" => Some(Self::ProcessServiceDataDecoder),
                "PROCESS_SERVICE_UTIL_WIN" => Some(Self::ProcessServiceUtilWin),
                "PROCESS_SERVICE_PROXY_RESOLVER" => {
                    Some(Self::ProcessServiceProxyResolver)
                }
                "PROCESS_SERVICE_CDM" => Some(Self::ProcessServiceCdm),
                "PROCESS_SERVICE_VIDEO_CAPTURE" => Some(Self::ProcessServiceVideoCapture),
                "PROCESS_SERVICE_UNZIPPER" => Some(Self::ProcessServiceUnzipper),
                "PROCESS_SERVICE_MIRRORING" => Some(Self::ProcessServiceMirroring),
                "PROCESS_SERVICE_FILEPATCHER" => Some(Self::ProcessServiceFilepatcher),
                "PROCESS_SERVICE_TTS" => Some(Self::ProcessServiceTts),
                "PROCESS_SERVICE_PRINTING" => Some(Self::ProcessServicePrinting),
                "PROCESS_SERVICE_QUARANTINE" => Some(Self::ProcessServiceQuarantine),
                "PROCESS_SERVICE_CROS_LOCALSEARCH" => {
                    Some(Self::ProcessServiceCrosLocalsearch)
                }
                "PROCESS_SERVICE_CROS_ASSISTANT_AUDIO_DECODER" => {
                    Some(Self::ProcessServiceCrosAssistantAudioDecoder)
                }
                "PROCESS_SERVICE_FILEUTIL" => Some(Self::ProcessServiceFileutil),
                "PROCESS_SERVICE_PRINTCOMPOSITOR" => {
                    Some(Self::ProcessServicePrintcompositor)
                }
                "PROCESS_SERVICE_PAINTPREVIEW" => Some(Self::ProcessServicePaintpreview),
                "PROCESS_SERVICE_SPEECHRECOGNITION" => {
                    Some(Self::ProcessServiceSpeechrecognition)
                }
                "PROCESS_SERVICE_XRDEVICE" => Some(Self::ProcessServiceXrdevice),
                "PROCESS_SERVICE_READICON" => Some(Self::ProcessServiceReadicon),
                "PROCESS_SERVICE_LANGUAGEDETECTION" => {
                    Some(Self::ProcessServiceLanguagedetection)
                }
                "PROCESS_SERVICE_SHARING" => Some(Self::ProcessServiceSharing),
                "PROCESS_SERVICE_MEDIAPARSER" => Some(Self::ProcessServiceMediaparser),
                "PROCESS_SERVICE_QRCODEGENERATOR" => {
                    Some(Self::ProcessServiceQrcodegenerator)
                }
                "PROCESS_SERVICE_PROFILEIMPORT" => {
                    Some(Self::ProcessServiceProfileimport)
                }
                "PROCESS_SERVICE_IME" => Some(Self::ProcessServiceIme),
                "PROCESS_SERVICE_RECORDING" => Some(Self::ProcessServiceRecording),
                "PROCESS_SERVICE_SHAPEDETECTION" => {
                    Some(Self::ProcessServiceShapedetection)
                }
                "PROCESS_RENDERER_EXTENSION" => Some(Self::ProcessRendererExtension),
                "PROCESS_SERVICE_MEDIA_FOUNDATION" => {
                    Some(Self::ProcessServiceMediaFoundation)
                }
                _ => None,
            }
        }
    }
}
/// Describes a Chrome thread's attributes. Emitted as part of a TrackDescriptor,
/// usually by the thread's trace writer. Must be paired with a ThreadDescriptor
/// in the same TrackDescriptor.
///
/// Next id: 3.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeThreadDescriptor {
    #[prost(enumeration = "chrome_thread_descriptor::ThreadType", optional, tag = "1")]
    pub thread_type: ::core::option::Option<i32>,
    /// To support old UI. New UI should determine default sorting by thread_type.
    #[prost(int32, optional, tag = "2")]
    pub legacy_sort_index: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ChromeThreadDescriptor`.
pub mod chrome_thread_descriptor {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ThreadType {
        ThreadUnspecified = 0,
        ThreadMain = 1,
        ThreadIo = 2,
        ThreadPoolBgWorker = 3,
        ThreadPoolFgWorker = 4,
        ThreadPoolFgBlocking = 5,
        ThreadPoolBgBlocking = 6,
        ThreadPoolService = 7,
        ThreadCompositor = 8,
        ThreadVizCompositor = 9,
        ThreadCompositorWorker = 10,
        ThreadServiceWorker = 11,
        ThreadNetworkService = 12,
        ThreadChildIo = 13,
        ThreadBrowserIo = 14,
        ThreadBrowserMain = 15,
        ThreadRendererMain = 16,
        ThreadUtilityMain = 17,
        ThreadGpuMain = 18,
        ThreadCacheBlockfile = 19,
        ThreadMedia = 20,
        ThreadAudioOutputdevice = 21,
        ThreadAudioInputdevice = 22,
        ThreadGpuMemory = 23,
        ThreadGpuVsync = 24,
        ThreadDxaVideodecoder = 25,
        ThreadBrowserWatchdog = 26,
        ThreadWebrtcNetwork = 27,
        ThreadWindowOwner = 28,
        ThreadWebrtcSignaling = 29,
        ThreadWebrtcWorker = 30,
        ThreadPpapiMain = 31,
        ThreadGpuWatchdog = 32,
        ThreadSwapper = 33,
        ThreadGamepadPolling = 34,
        ThreadWebcrypto = 35,
        ThreadDatabase = 36,
        ThreadProxyresolver = 37,
        ThreadDevtoolsadb = 38,
        ThreadNetworkconfigwatcher = 39,
        ThreadWasapiRender = 40,
        ThreadLoaderLockSampler = 41,
        ThreadMemoryInfra = 50,
        ThreadSamplingProfiler = 51,
        ThreadCompositorGpu = 52,
    }
    impl ThreadType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ThreadUnspecified => "THREAD_UNSPECIFIED",
                Self::ThreadMain => "THREAD_MAIN",
                Self::ThreadIo => "THREAD_IO",
                Self::ThreadPoolBgWorker => "THREAD_POOL_BG_WORKER",
                Self::ThreadPoolFgWorker => "THREAD_POOL_FG_WORKER",
                Self::ThreadPoolFgBlocking => "THREAD_POOL_FG_BLOCKING",
                Self::ThreadPoolBgBlocking => "THREAD_POOL_BG_BLOCKING",
                Self::ThreadPoolService => "THREAD_POOL_SERVICE",
                Self::ThreadCompositor => "THREAD_COMPOSITOR",
                Self::ThreadVizCompositor => "THREAD_VIZ_COMPOSITOR",
                Self::ThreadCompositorWorker => "THREAD_COMPOSITOR_WORKER",
                Self::ThreadServiceWorker => "THREAD_SERVICE_WORKER",
                Self::ThreadNetworkService => "THREAD_NETWORK_SERVICE",
                Self::ThreadChildIo => "THREAD_CHILD_IO",
                Self::ThreadBrowserIo => "THREAD_BROWSER_IO",
                Self::ThreadBrowserMain => "THREAD_BROWSER_MAIN",
                Self::ThreadRendererMain => "THREAD_RENDERER_MAIN",
                Self::ThreadUtilityMain => "THREAD_UTILITY_MAIN",
                Self::ThreadGpuMain => "THREAD_GPU_MAIN",
                Self::ThreadCacheBlockfile => "THREAD_CACHE_BLOCKFILE",
                Self::ThreadMedia => "THREAD_MEDIA",
                Self::ThreadAudioOutputdevice => "THREAD_AUDIO_OUTPUTDEVICE",
                Self::ThreadAudioInputdevice => "THREAD_AUDIO_INPUTDEVICE",
                Self::ThreadGpuMemory => "THREAD_GPU_MEMORY",
                Self::ThreadGpuVsync => "THREAD_GPU_VSYNC",
                Self::ThreadDxaVideodecoder => "THREAD_DXA_VIDEODECODER",
                Self::ThreadBrowserWatchdog => "THREAD_BROWSER_WATCHDOG",
                Self::ThreadWebrtcNetwork => "THREAD_WEBRTC_NETWORK",
                Self::ThreadWindowOwner => "THREAD_WINDOW_OWNER",
                Self::ThreadWebrtcSignaling => "THREAD_WEBRTC_SIGNALING",
                Self::ThreadWebrtcWorker => "THREAD_WEBRTC_WORKER",
                Self::ThreadPpapiMain => "THREAD_PPAPI_MAIN",
                Self::ThreadGpuWatchdog => "THREAD_GPU_WATCHDOG",
                Self::ThreadSwapper => "THREAD_SWAPPER",
                Self::ThreadGamepadPolling => "THREAD_GAMEPAD_POLLING",
                Self::ThreadWebcrypto => "THREAD_WEBCRYPTO",
                Self::ThreadDatabase => "THREAD_DATABASE",
                Self::ThreadProxyresolver => "THREAD_PROXYRESOLVER",
                Self::ThreadDevtoolsadb => "THREAD_DEVTOOLSADB",
                Self::ThreadNetworkconfigwatcher => "THREAD_NETWORKCONFIGWATCHER",
                Self::ThreadWasapiRender => "THREAD_WASAPI_RENDER",
                Self::ThreadLoaderLockSampler => "THREAD_LOADER_LOCK_SAMPLER",
                Self::ThreadMemoryInfra => "THREAD_MEMORY_INFRA",
                Self::ThreadSamplingProfiler => "THREAD_SAMPLING_PROFILER",
                Self::ThreadCompositorGpu => "THREAD_COMPOSITOR_GPU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "THREAD_UNSPECIFIED" => Some(Self::ThreadUnspecified),
                "THREAD_MAIN" => Some(Self::ThreadMain),
                "THREAD_IO" => Some(Self::ThreadIo),
                "THREAD_POOL_BG_WORKER" => Some(Self::ThreadPoolBgWorker),
                "THREAD_POOL_FG_WORKER" => Some(Self::ThreadPoolFgWorker),
                "THREAD_POOL_FG_BLOCKING" => Some(Self::ThreadPoolFgBlocking),
                "THREAD_POOL_BG_BLOCKING" => Some(Self::ThreadPoolBgBlocking),
                "THREAD_POOL_SERVICE" => Some(Self::ThreadPoolService),
                "THREAD_COMPOSITOR" => Some(Self::ThreadCompositor),
                "THREAD_VIZ_COMPOSITOR" => Some(Self::ThreadVizCompositor),
                "THREAD_COMPOSITOR_WORKER" => Some(Self::ThreadCompositorWorker),
                "THREAD_SERVICE_WORKER" => Some(Self::ThreadServiceWorker),
                "THREAD_NETWORK_SERVICE" => Some(Self::ThreadNetworkService),
                "THREAD_CHILD_IO" => Some(Self::ThreadChildIo),
                "THREAD_BROWSER_IO" => Some(Self::ThreadBrowserIo),
                "THREAD_BROWSER_MAIN" => Some(Self::ThreadBrowserMain),
                "THREAD_RENDERER_MAIN" => Some(Self::ThreadRendererMain),
                "THREAD_UTILITY_MAIN" => Some(Self::ThreadUtilityMain),
                "THREAD_GPU_MAIN" => Some(Self::ThreadGpuMain),
                "THREAD_CACHE_BLOCKFILE" => Some(Self::ThreadCacheBlockfile),
                "THREAD_MEDIA" => Some(Self::ThreadMedia),
                "THREAD_AUDIO_OUTPUTDEVICE" => Some(Self::ThreadAudioOutputdevice),
                "THREAD_AUDIO_INPUTDEVICE" => Some(Self::ThreadAudioInputdevice),
                "THREAD_GPU_MEMORY" => Some(Self::ThreadGpuMemory),
                "THREAD_GPU_VSYNC" => Some(Self::ThreadGpuVsync),
                "THREAD_DXA_VIDEODECODER" => Some(Self::ThreadDxaVideodecoder),
                "THREAD_BROWSER_WATCHDOG" => Some(Self::ThreadBrowserWatchdog),
                "THREAD_WEBRTC_NETWORK" => Some(Self::ThreadWebrtcNetwork),
                "THREAD_WINDOW_OWNER" => Some(Self::ThreadWindowOwner),
                "THREAD_WEBRTC_SIGNALING" => Some(Self::ThreadWebrtcSignaling),
                "THREAD_WEBRTC_WORKER" => Some(Self::ThreadWebrtcWorker),
                "THREAD_PPAPI_MAIN" => Some(Self::ThreadPpapiMain),
                "THREAD_GPU_WATCHDOG" => Some(Self::ThreadGpuWatchdog),
                "THREAD_SWAPPER" => Some(Self::ThreadSwapper),
                "THREAD_GAMEPAD_POLLING" => Some(Self::ThreadGamepadPolling),
                "THREAD_WEBCRYPTO" => Some(Self::ThreadWebcrypto),
                "THREAD_DATABASE" => Some(Self::ThreadDatabase),
                "THREAD_PROXYRESOLVER" => Some(Self::ThreadProxyresolver),
                "THREAD_DEVTOOLSADB" => Some(Self::ThreadDevtoolsadb),
                "THREAD_NETWORKCONFIGWATCHER" => Some(Self::ThreadNetworkconfigwatcher),
                "THREAD_WASAPI_RENDER" => Some(Self::ThreadWasapiRender),
                "THREAD_LOADER_LOCK_SAMPLER" => Some(Self::ThreadLoaderLockSampler),
                "THREAD_MEMORY_INFRA" => Some(Self::ThreadMemoryInfra),
                "THREAD_SAMPLING_PROFILER" => Some(Self::ThreadSamplingProfiler),
                "THREAD_COMPOSITOR_GPU" => Some(Self::ThreadCompositorGpu),
                _ => None,
            }
        }
    }
}
/// Describes a process's attributes. Emitted as part of a TrackDescriptor,
/// usually by the process's main thread.
///
/// Next id: 9.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessDescriptor {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "2")]
    pub cmdline: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub process_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "5")]
    pub process_priority: ::core::option::Option<i32>,
    /// Process start time in nanoseconds.
    /// The timestamp refers to the trace clock by default. Other clock IDs
    /// provided in TracePacket are not supported.
    #[prost(int64, optional, tag = "7")]
    pub start_timestamp_ns: ::core::option::Option<i64>,
    #[prost(enumeration = "process_descriptor::ChromeProcessType", optional, tag = "4")]
    pub chrome_process_type: ::core::option::Option<i32>,
    /// To support old UI. New UI should determine default sorting by process_type.
    #[prost(int32, optional, tag = "3")]
    pub legacy_sort_index: ::core::option::Option<i32>,
    /// Labels can be used to further describe properties of the work performed by
    /// the process. For example, these can be used by Chrome renderer process to
    /// provide titles of frames being rendered.
    #[prost(string, repeated, tag = "8")]
    pub process_labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ProcessDescriptor`.
pub mod process_descriptor {
    /// See chromium's content::ProcessType.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChromeProcessType {
        ProcessUnspecified = 0,
        ProcessBrowser = 1,
        ProcessRenderer = 2,
        ProcessUtility = 3,
        ProcessZygote = 4,
        ProcessSandboxHelper = 5,
        ProcessGpu = 6,
        ProcessPpapiPlugin = 7,
        ProcessPpapiBroker = 8,
    }
    impl ChromeProcessType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ProcessUnspecified => "PROCESS_UNSPECIFIED",
                Self::ProcessBrowser => "PROCESS_BROWSER",
                Self::ProcessRenderer => "PROCESS_RENDERER",
                Self::ProcessUtility => "PROCESS_UTILITY",
                Self::ProcessZygote => "PROCESS_ZYGOTE",
                Self::ProcessSandboxHelper => "PROCESS_SANDBOX_HELPER",
                Self::ProcessGpu => "PROCESS_GPU",
                Self::ProcessPpapiPlugin => "PROCESS_PPAPI_PLUGIN",
                Self::ProcessPpapiBroker => "PROCESS_PPAPI_BROKER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROCESS_UNSPECIFIED" => Some(Self::ProcessUnspecified),
                "PROCESS_BROWSER" => Some(Self::ProcessBrowser),
                "PROCESS_RENDERER" => Some(Self::ProcessRenderer),
                "PROCESS_UTILITY" => Some(Self::ProcessUtility),
                "PROCESS_ZYGOTE" => Some(Self::ProcessZygote),
                "PROCESS_SANDBOX_HELPER" => Some(Self::ProcessSandboxHelper),
                "PROCESS_GPU" => Some(Self::ProcessGpu),
                "PROCESS_PPAPI_PLUGIN" => Some(Self::ProcessPpapiPlugin),
                "PROCESS_PPAPI_BROKER" => Some(Self::ProcessPpapiBroker),
                _ => None,
            }
        }
    }
}
/// Describes a thread's attributes. Emitted as part of a TrackDescriptor,
/// usually by the thread's trace writer.
///
/// Next id: 9.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreadDescriptor {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub tid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub thread_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "thread_descriptor::ChromeThreadType", optional, tag = "4")]
    pub chrome_thread_type: ::core::option::Option<i32>,
    /// Deprecated. Use ClockSnapshot in combination with TracePacket's timestamp
    /// and timestamp_clock_id fields instead.
    #[prost(int64, optional, tag = "6")]
    pub reference_timestamp_us: ::core::option::Option<i64>,
    /// Absolute reference values. Clock values in subsequent TrackEvents can be
    /// encoded accumulatively and relative to these. This reduces their var-int
    /// encoding size.
    /// TODO(eseckler): Deprecated. Replace these with ClockSnapshot encoding.
    #[prost(int64, optional, tag = "7")]
    pub reference_thread_time_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub reference_thread_instruction_count: ::core::option::Option<i64>,
    /// To support old UI. New UI should determine default sorting by thread_type.
    #[prost(int32, optional, tag = "3")]
    pub legacy_sort_index: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ThreadDescriptor`.
pub mod thread_descriptor {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChromeThreadType {
        ChromeThreadUnspecified = 0,
        ChromeThreadMain = 1,
        ChromeThreadIo = 2,
        /// Scheduler:
        ChromeThreadPoolBgWorker = 3,
        ChromeThreadPoolFgWorker = 4,
        ChromeThreadPoolFbBlocking = 5,
        ChromeThreadPoolBgBlocking = 6,
        ChromeThreadPoolService = 7,
        /// Compositor:
        ChromeThreadCompositor = 8,
        ChromeThreadVizCompositor = 9,
        ChromeThreadCompositorWorker = 10,
        /// Renderer:
        ChromeThreadServiceWorker = 11,
        /// Tracing related threads:
        ChromeThreadMemoryInfra = 50,
        ChromeThreadSamplingProfiler = 51,
    }
    impl ChromeThreadType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ChromeThreadUnspecified => "CHROME_THREAD_UNSPECIFIED",
                Self::ChromeThreadMain => "CHROME_THREAD_MAIN",
                Self::ChromeThreadIo => "CHROME_THREAD_IO",
                Self::ChromeThreadPoolBgWorker => "CHROME_THREAD_POOL_BG_WORKER",
                Self::ChromeThreadPoolFgWorker => "CHROME_THREAD_POOL_FG_WORKER",
                Self::ChromeThreadPoolFbBlocking => "CHROME_THREAD_POOL_FB_BLOCKING",
                Self::ChromeThreadPoolBgBlocking => "CHROME_THREAD_POOL_BG_BLOCKING",
                Self::ChromeThreadPoolService => "CHROME_THREAD_POOL_SERVICE",
                Self::ChromeThreadCompositor => "CHROME_THREAD_COMPOSITOR",
                Self::ChromeThreadVizCompositor => "CHROME_THREAD_VIZ_COMPOSITOR",
                Self::ChromeThreadCompositorWorker => "CHROME_THREAD_COMPOSITOR_WORKER",
                Self::ChromeThreadServiceWorker => "CHROME_THREAD_SERVICE_WORKER",
                Self::ChromeThreadMemoryInfra => "CHROME_THREAD_MEMORY_INFRA",
                Self::ChromeThreadSamplingProfiler => "CHROME_THREAD_SAMPLING_PROFILER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHROME_THREAD_UNSPECIFIED" => Some(Self::ChromeThreadUnspecified),
                "CHROME_THREAD_MAIN" => Some(Self::ChromeThreadMain),
                "CHROME_THREAD_IO" => Some(Self::ChromeThreadIo),
                "CHROME_THREAD_POOL_BG_WORKER" => Some(Self::ChromeThreadPoolBgWorker),
                "CHROME_THREAD_POOL_FG_WORKER" => Some(Self::ChromeThreadPoolFgWorker),
                "CHROME_THREAD_POOL_FB_BLOCKING" => {
                    Some(Self::ChromeThreadPoolFbBlocking)
                }
                "CHROME_THREAD_POOL_BG_BLOCKING" => {
                    Some(Self::ChromeThreadPoolBgBlocking)
                }
                "CHROME_THREAD_POOL_SERVICE" => Some(Self::ChromeThreadPoolService),
                "CHROME_THREAD_COMPOSITOR" => Some(Self::ChromeThreadCompositor),
                "CHROME_THREAD_VIZ_COMPOSITOR" => Some(Self::ChromeThreadVizCompositor),
                "CHROME_THREAD_COMPOSITOR_WORKER" => {
                    Some(Self::ChromeThreadCompositorWorker)
                }
                "CHROME_THREAD_SERVICE_WORKER" => Some(Self::ChromeThreadServiceWorker),
                "CHROME_THREAD_MEMORY_INFRA" => Some(Self::ChromeThreadMemoryInfra),
                "CHROME_THREAD_SAMPLING_PROFILER" => {
                    Some(Self::ChromeThreadSamplingProfiler)
                }
                _ => None,
            }
        }
    }
}
/// Defines properties of a counter track, e.g. for built-in counters (thread
/// time, instruction count, ..) or user-specified counters (e.g. memory usage of
/// a specific app component).
///
/// Counter tracks only support TYPE_COUNTER track events, which specify new
/// values for the counter. For counters that require per-slice values, counter
/// values can instead be provided in a more efficient encoding via TrackEvent's
/// |extra_counter_track_uuids| and |extra_counter_values| fields. However,
/// slice-type events cannot be emitted onto a counter track.
///
/// Values for counters that are only emitted on a single packet sequence can
/// optionally be delta-encoded, see |is_incremental|.
///
/// Next id: 7.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CounterDescriptor {
    /// For built-in counters (e.g. thread time). Custom user-specified counters
    /// (e.g. those emitted by TRACE_COUNTER macros of the client library)
    /// shouldn't set this, and instead provide a counter name via TrackDescriptor.
    #[prost(enumeration = "counter_descriptor::BuiltinCounterType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    /// Names of categories of the counter (usually for user-specified counters).
    /// In the client library, categories are a way to turn groups of individual
    /// counters (or events) on or off.
    #[prost(string, repeated, tag = "2")]
    pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Type of the counter's values. Built-in counters imply a value for this
    /// field.
    #[prost(enumeration = "counter_descriptor::Unit", optional, tag = "3")]
    pub unit: ::core::option::Option<i32>,
    /// In order to use a unit not defined as a part of |Unit|, a free-form unit
    /// name can be used instead.
    #[prost(string, optional, tag = "6")]
    pub unit_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Multiplication factor of this counter's values, e.g. to supply
    /// COUNTER_THREAD_TIME_NS timestamps in microseconds instead.
    #[prost(int64, optional, tag = "4")]
    pub unit_multiplier: ::core::option::Option<i64>,
    /// Whether values for this counter are provided as delta values. Only
    /// supported for counters that are emitted on a single packet-sequence (e.g.
    /// thread time). Counter values in subsequent packets on the current packet
    /// sequence will be interpreted as delta values from the sequence's most
    /// recent value for the counter. When incremental state is cleared, the
    /// counter value is considered to be reset to 0. Thus, the first value after
    /// incremental state is cleared is effectively an absolute value.
    #[prost(bool, optional, tag = "5")]
    pub is_incremental: ::core::option::Option<bool>,
}
/// Nested message and enum types in `CounterDescriptor`.
pub mod counter_descriptor {
    /// Built-in counters, usually with special meaning in the client library,
    /// trace processor, legacy JSON format, or UI. Trace processor will infer a
    /// track name from the enum value if none is provided in TrackDescriptor.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BuiltinCounterType {
        CounterUnspecified = 0,
        /// implies UNIT_TIME_NS.
        CounterThreadTimeNs = 1,
        /// implies UNIT_COUNT.
        CounterThreadInstructionCount = 2,
    }
    impl BuiltinCounterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::CounterUnspecified => "COUNTER_UNSPECIFIED",
                Self::CounterThreadTimeNs => "COUNTER_THREAD_TIME_NS",
                Self::CounterThreadInstructionCount => "COUNTER_THREAD_INSTRUCTION_COUNT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COUNTER_UNSPECIFIED" => Some(Self::CounterUnspecified),
                "COUNTER_THREAD_TIME_NS" => Some(Self::CounterThreadTimeNs),
                "COUNTER_THREAD_INSTRUCTION_COUNT" => {
                    Some(Self::CounterThreadInstructionCount)
                }
                _ => None,
            }
        }
    }
    /// Type of the values for the counters - to supply lower granularity units,
    /// see also |unit_multiplier|.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Unit {
        Unspecified = 0,
        TimeNs = 1,
        Count = 2,
        /// TODO(eseckler): Support more units as necessary.
        SizeBytes = 3,
    }
    impl Unit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNIT_UNSPECIFIED",
                Self::TimeNs => "UNIT_TIME_NS",
                Self::Count => "UNIT_COUNT",
                Self::SizeBytes => "UNIT_SIZE_BYTES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "UNIT_TIME_NS" => Some(Self::TimeNs),
                "UNIT_COUNT" => Some(Self::Count),
                "UNIT_SIZE_BYTES" => Some(Self::SizeBytes),
                _ => None,
            }
        }
    }
}
/// Defines a track for TrackEvents. Slices and instant events on the same track
/// will be nested based on their timestamps, see TrackEvent::Type.
///
/// A TrackDescriptor only needs to be emitted by one trace writer / producer and
/// is valid for the entirety of the trace. To ensure the descriptor isn't lost
/// when the ring buffer wraps, it should be reemitted whenever incremental state
/// is cleared.
///
/// As a fallback, TrackEvents emitted without an explicit track association will
/// be associated with an implicit trace-global track (uuid = 0), see also
/// |TrackEvent::track_uuid|. It is possible but not necessary to emit a
/// TrackDescriptor for this implicit track.
///
/// Next id: 14.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrackDescriptor {
    /// Unique ID that identifies this track. This ID is global to the whole trace.
    /// Producers should ensure that it is unlikely to clash with IDs emitted by
    /// other producers. A value of 0 denotes the implicit trace-global track.
    ///
    /// For example, legacy TRACE_EVENT macros may use a hash involving the async
    /// event id + id_scope, pid, and/or tid to compute this ID.
    #[prost(uint64, optional, tag = "1")]
    pub uuid: ::core::option::Option<u64>,
    /// A parent track reference can be used to describe relationships between
    /// tracks. For example, to define an asynchronous track which is scoped to a
    /// specific process, specify the uuid for that process's process track here.
    /// Similarly, to associate a COUNTER_THREAD_TIME_NS counter track with a
    /// thread, specify the uuid for that thread's thread track here. In general,
    /// setting a parent will *nest* that track under the parent in the UI and in
    /// the trace processor data model (with the important exception noted below).
    ///
    /// If not specified, the track will be a root track, i.e. not nested under any
    /// other track.
    ///
    /// Note: if the `thread` or `process` fields are set, this value will be
    /// *ignored* as priority is given to those fields.
    ///
    /// Note: if the parent is set to a track with `thread` or `process` fields
    /// set, the track will *not* be nested under the parent in the UI and in the
    /// trace processor data model. Instead, the track will inherit the parent'
    /// thread/process association and will appear as a *sibling* of the parent.
    /// This semantic exists for back-compat reasons as the UI used to work this
    /// way for years and changing this leads to a lot of traces subtly breaking.
    /// If you want to force nesting, create *another* intermediate track to act as
    /// the parent.
    #[prost(uint64, optional, tag = "5")]
    pub parent_uuid: ::core::option::Option<u64>,
    /// Associate the track with a process, making it the process-global track.
    /// There should only be one such track per process (usually for instant
    /// events; trace processor uses this fact to detect pid reuse). If you need
    /// more (e.g. for asynchronous events), create child tracks using parent_uuid.
    ///
    /// Trace processor will merge events on a process track with slice-type events
    /// from other sources (e.g. ftrace) for the same process into a single
    /// timeline view.
    #[prost(message, optional, tag = "3")]
    pub process: ::core::option::Option<ProcessDescriptor>,
    #[prost(message, optional, tag = "6")]
    pub chrome_process: ::core::option::Option<ChromeProcessDescriptor>,
    /// Associate the track with a thread, indicating that the track's events
    /// describe synchronous code execution on the thread. There should only be one
    /// such track per thread (trace processor uses this fact to detect tid reuse).
    ///
    /// Trace processor will merge events on a thread track with slice-type events
    /// from other sources (e.g. ftrace) for the same thread into a single timeline
    /// view.
    #[prost(message, optional, tag = "4")]
    pub thread: ::core::option::Option<ThreadDescriptor>,
    #[prost(message, optional, tag = "7")]
    pub chrome_thread: ::core::option::Option<ChromeThreadDescriptor>,
    /// Descriptor for a counter track. If set, the track will only support
    /// TYPE_COUNTER TrackEvents (and values provided via TrackEvent's
    /// |extra_counter_values|).
    #[prost(message, optional, tag = "8")]
    pub counter: ::core::option::Option<CounterDescriptor>,
    /// If true, forces Trace Processor to use separate tracks for track events
    /// and system events for the same thread.
    /// Track events timestamps in Chrome have microsecond resolution, while
    /// system events use nanoseconds. It results in broken event nesting when
    /// track events and system events share a track.
    #[prost(bool, optional, tag = "9")]
    pub disallow_merging_with_system_tracks: ::core::option::Option<bool>,
    #[prost(enumeration = "track_descriptor::ChildTracksOrdering", optional, tag = "11")]
    pub child_ordering: ::core::option::Option<i32>,
    /// An opaque value which allows specifying how two sibling tracks should be
    /// ordered relative to each other: tracks with lower ranks will appear before
    /// tracks with higher ranks. An unspecified rank will be treated as a rank of
    /// 0.
    ///
    /// Note: for tracks where the parent has `thread` or `process` are set, this
    /// option is *ignored*. See `parent_uuid` for details.
    #[prost(int32, optional, tag = "12")]
    pub sibling_order_rank: ::core::option::Option<i32>,
    /// Name of the track. Optional - if unspecified, it may be derived from the
    /// process/thread name (process/thread tracks), the first event's name (async
    /// tracks), or counter name (counter tracks).
    #[prost(oneof = "track_descriptor::StaticOrDynamicName", tags = "2, 10, 13")]
    pub static_or_dynamic_name: ::core::option::Option<
        track_descriptor::StaticOrDynamicName,
    >,
}
/// Nested message and enum types in `TrackDescriptor`.
pub mod track_descriptor {
    /// Specifies how the UI should display child tracks of this track (i.e. tracks
    /// where `parent_uuid` is specified to this track `uuid`). Note that this
    /// value is simply a *hint* to the UI: the UI is not guarnateed to respect
    /// this if it has a good reason not to do so.
    ///
    /// Note: for tracks where `thread` or `process` are set, this option is
    /// *ignored*. See `parent_uuid` for details.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChildTracksOrdering {
        /// The default ordering, with no bearing on how the UI will visualise the
        /// tracks.
        Unknown = 0,
        /// Order tracks by `name` or `static_name` depending on which one has been
        /// specified.
        Lexicographic = 1,
        /// Order tracks by the first `ts` event in a track.
        Chronological = 2,
        /// Order tracks by `sibling_order_rank` of child tracks. Child tracks with
        /// the lower values will be shown before tracks with higher values. Tracks
        /// with no value will be treated as having 0 rank.
        Explicit = 3,
    }
    impl ChildTracksOrdering {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Lexicographic => "LEXICOGRAPHIC",
                Self::Chronological => "CHRONOLOGICAL",
                Self::Explicit => "EXPLICIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "LEXICOGRAPHIC" => Some(Self::Lexicographic),
                "CHRONOLOGICAL" => Some(Self::Chronological),
                "EXPLICIT" => Some(Self::Explicit),
                _ => None,
            }
        }
    }
    /// Name of the track. Optional - if unspecified, it may be derived from the
    /// process/thread name (process/thread tracks), the first event's name (async
    /// tracks), or counter name (counter tracks).
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StaticOrDynamicName {
        #[prost(string, tag = "2")]
        Name(::prost::alloc::string::String),
        /// This field is only set by the SDK when perfetto::StaticString is
        /// provided.
        #[prost(string, tag = "10")]
        StaticName(::prost::alloc::string::String),
        /// Equivalent to name, used just to mark that the data is coming from
        /// android.os.Trace.
        #[prost(string, tag = "13")]
        AtraceName(::prost::alloc::string::String),
    }
}
/// Proto representation of untyped key/value annotations provided in TRACE_EVENT
/// macros. Users of the Perfetto SDK should prefer to use the
/// perfetto::TracedValue API to fill these protos, rather than filling them
/// manually.
///
/// Debug annotations are intended for debug use and are not considered a stable
/// API of the trace contents. Trace-based metrics that use debug annotation
/// values are prone to breakage, so please rely on typed TrackEvent fields for
/// these instead.
///
/// DebugAnnotations support nested arrays and dictionaries. Each entry is
/// encoded as a single DebugAnnotation message. Only dictionary entries
/// set the "name" field. The TrackEvent message forms an implicit root
/// dictionary.
///
/// Example TrackEvent with nested annotations:
///    track_event {
///      debug_annotations {
///        name: "foo"
///        dict_entries {
///          name: "a"
///          bool_value: true
///        }
///        dict_entries {
///          name: "b"
///          int_value: 123
///        }
///      }
///      debug_annotations {
///        name: "bar"
///        array_values {
///          string_value: "hello"
///        }
///        array_values {
///          string_value: "world"
///        }
///      }
///    }
///
/// Next ID: 18.
/// Reserved ID: 15
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DebugAnnotation {
    #[prost(bytes = "vec", optional, tag = "14")]
    pub proto_value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "11")]
    pub dict_entries: ::prost::alloc::vec::Vec<DebugAnnotation>,
    #[prost(message, repeated, tag = "12")]
    pub array_values: ::prost::alloc::vec::Vec<DebugAnnotation>,
    /// Name fields are set only for dictionary entries.
    #[prost(oneof = "debug_annotation::NameField", tags = "1, 10")]
    pub name_field: ::core::option::Option<debug_annotation::NameField>,
    #[prost(oneof = "debug_annotation::Value", tags = "2, 3, 4, 5, 7, 8, 9, 6, 17")]
    pub value: ::core::option::Option<debug_annotation::Value>,
    /// Used to embed arbitrary proto messages (which are also typically used to
    /// represent typed TrackEvent arguments). |proto_type_name| or
    /// |proto_type_name_iid| are storing the full name of the proto messages (e.g.
    /// .perfetto.protos.DebugAnnotation) and |proto_value| contains the serialised
    /// proto messages. See |TracedValue::WriteProto| for more details.
    #[prost(oneof = "debug_annotation::ProtoTypeDescriptor", tags = "16, 13")]
    pub proto_type_descriptor: ::core::option::Option<
        debug_annotation::ProtoTypeDescriptor,
    >,
}
/// Nested message and enum types in `DebugAnnotation`.
pub mod debug_annotation {
    /// Deprecated legacy way to use nested values. Only kept for
    /// backwards-compatibility in TraceProcessor. May be removed in the future -
    /// code filling protos should use |dict_entries| and |array_values| instead.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NestedValue {
        #[prost(enumeration = "nested_value::NestedType", optional, tag = "1")]
        pub nested_type: ::core::option::Option<i32>,
        #[prost(string, repeated, tag = "2")]
        pub dict_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "3")]
        pub dict_values: ::prost::alloc::vec::Vec<NestedValue>,
        #[prost(message, repeated, tag = "4")]
        pub array_values: ::prost::alloc::vec::Vec<NestedValue>,
        #[prost(int64, optional, tag = "5")]
        pub int_value: ::core::option::Option<i64>,
        #[prost(double, optional, tag = "6")]
        pub double_value: ::core::option::Option<f64>,
        #[prost(bool, optional, tag = "7")]
        pub bool_value: ::core::option::Option<bool>,
        #[prost(string, optional, tag = "8")]
        pub string_value: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `NestedValue`.
    pub mod nested_value {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum NestedType {
            /// leaf value.
            Unspecified = 0,
            Dict = 1,
            Array = 2,
        }
        impl NestedType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Dict => "DICT",
                    Self::Array => "ARRAY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "DICT" => Some(Self::Dict),
                    "ARRAY" => Some(Self::Array),
                    _ => None,
                }
            }
        }
    }
    /// Name fields are set only for dictionary entries.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum NameField {
        /// interned DebugAnnotationName.
        #[prost(uint64, tag = "1")]
        NameIid(u64),
        /// non-interned variant.
        #[prost(string, tag = "10")]
        Name(::prost::alloc::string::String),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(bool, tag = "2")]
        BoolValue(bool),
        #[prost(uint64, tag = "3")]
        UintValue(u64),
        #[prost(int64, tag = "4")]
        IntValue(i64),
        #[prost(double, tag = "5")]
        DoubleValue(f64),
        /// Pointers are stored in a separate type as the JSON output treats them
        /// differently from other uint64 values.
        #[prost(uint64, tag = "7")]
        PointerValue(u64),
        /// Deprecated. Use dict_entries / array_values instead.
        #[prost(message, tag = "8")]
        NestedValue(NestedValue),
        /// Legacy instrumentation may not support conversion of nested data to
        /// NestedValue yet.
        #[prost(string, tag = "9")]
        LegacyJsonValue(::prost::alloc::string::String),
        /// interned and non-interned variants of strings.
        #[prost(string, tag = "6")]
        StringValue(::prost::alloc::string::String),
        /// Corresponds to |debug_annotation_string_values| field in InternedData.
        #[prost(uint64, tag = "17")]
        StringValueIid(u64),
    }
    /// Used to embed arbitrary proto messages (which are also typically used to
    /// represent typed TrackEvent arguments). |proto_type_name| or
    /// |proto_type_name_iid| are storing the full name of the proto messages (e.g.
    /// .perfetto.protos.DebugAnnotation) and |proto_value| contains the serialised
    /// proto messages. See |TracedValue::WriteProto| for more details.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ProtoTypeDescriptor {
        #[prost(string, tag = "16")]
        ProtoTypeName(::prost::alloc::string::String),
        /// interned DebugAnnotationValueTypeName.
        #[prost(uint64, tag = "13")]
        ProtoTypeNameIid(u64),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DebugAnnotationName {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
/// See the |proto_type_descriptor| comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DebugAnnotationValueTypeName {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LogMessage {
    /// interned SourceLocation.
    #[prost(uint64, optional, tag = "1")]
    pub source_location_iid: ::core::option::Option<u64>,
    /// interned LogMessageBody.
    #[prost(uint64, optional, tag = "2")]
    pub body_iid: ::core::option::Option<u64>,
    #[prost(enumeration = "log_message::Priority", optional, tag = "3")]
    pub prio: ::core::option::Option<i32>,
}
/// Nested message and enum types in `LogMessage`.
pub mod log_message {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Priority {
        PrioUnspecified = 0,
        PrioUnused = 1,
        PrioVerbose = 2,
        PrioDebug = 3,
        PrioInfo = 4,
        PrioWarn = 5,
        PrioError = 6,
        PrioFatal = 7,
    }
    impl Priority {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::PrioUnspecified => "PRIO_UNSPECIFIED",
                Self::PrioUnused => "PRIO_UNUSED",
                Self::PrioVerbose => "PRIO_VERBOSE",
                Self::PrioDebug => "PRIO_DEBUG",
                Self::PrioInfo => "PRIO_INFO",
                Self::PrioWarn => "PRIO_WARN",
                Self::PrioError => "PRIO_ERROR",
                Self::PrioFatal => "PRIO_FATAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRIO_UNSPECIFIED" => Some(Self::PrioUnspecified),
                "PRIO_UNUSED" => Some(Self::PrioUnused),
                "PRIO_VERBOSE" => Some(Self::PrioVerbose),
                "PRIO_DEBUG" => Some(Self::PrioDebug),
                "PRIO_INFO" => Some(Self::PrioInfo),
                "PRIO_WARN" => Some(Self::PrioWarn),
                "PRIO_ERROR" => Some(Self::PrioError),
                "PRIO_FATAL" => Some(Self::PrioFatal),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogMessageBody {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub body: ::core::option::Option<::prost::alloc::string::String>,
}
/// TrackEvent arguments describing the execution of a task.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TaskExecution {
    /// Source location that the task was posted from.
    /// interned SourceLocation.
    #[prost(uint64, optional, tag = "1")]
    pub posted_from_iid: ::core::option::Option<u64>,
}
/// A list of processes connected to the tracing service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeActiveProcesses {
    #[prost(int32, repeated, packed = "false", tag = "1")]
    pub pid: ::prost::alloc::vec::Vec<i32>,
}
/// Trace event arguments for application state changes.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeApplicationStateInfo {
    #[prost(
        enumeration = "chrome_application_state_info::ChromeApplicationState",
        optional,
        tag = "1"
    )]
    pub application_state: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ChromeApplicationStateInfo`.
pub mod chrome_application_state_info {
    /// Enum definition taken from:
    /// <https://source.chromium.org/chromium/chromium/src/+/master:base/android/application_status_listener.h>
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChromeApplicationState {
        ApplicationStateUnknown = 0,
        ApplicationStateHasRunningActivities = 1,
        ApplicationStateHasPausedActivities = 2,
        ApplicationStateHasStoppedActivities = 3,
        ApplicationStateHasDestroyedActivities = 4,
    }
    impl ChromeApplicationState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ApplicationStateUnknown => "APPLICATION_STATE_UNKNOWN",
                Self::ApplicationStateHasRunningActivities => {
                    "APPLICATION_STATE_HAS_RUNNING_ACTIVITIES"
                }
                Self::ApplicationStateHasPausedActivities => {
                    "APPLICATION_STATE_HAS_PAUSED_ACTIVITIES"
                }
                Self::ApplicationStateHasStoppedActivities => {
                    "APPLICATION_STATE_HAS_STOPPED_ACTIVITIES"
                }
                Self::ApplicationStateHasDestroyedActivities => {
                    "APPLICATION_STATE_HAS_DESTROYED_ACTIVITIES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "APPLICATION_STATE_UNKNOWN" => Some(Self::ApplicationStateUnknown),
                "APPLICATION_STATE_HAS_RUNNING_ACTIVITIES" => {
                    Some(Self::ApplicationStateHasRunningActivities)
                }
                "APPLICATION_STATE_HAS_PAUSED_ACTIVITIES" => {
                    Some(Self::ApplicationStateHasPausedActivities)
                }
                "APPLICATION_STATE_HAS_STOPPED_ACTIVITIES" => {
                    Some(Self::ApplicationStateHasStoppedActivities)
                }
                "APPLICATION_STATE_HAS_DESTROYED_ACTIVITIES" => {
                    Some(Self::ApplicationStateHasDestroyedActivities)
                }
                _ => None,
            }
        }
    }
}
/// A source location, represented as a native symbol.
/// This is similar to `message Frame` from
/// protos/perfetto/trace/profiling/profile_common.proto, but for abitrary
/// source code locations (for example in track event args), not stack frames.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnsymbolizedSourceLocation {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub mapping_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub rel_pc: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceLocation {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub file_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub function_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub line_number: ::core::option::Option<u32>,
}
/// Next id: 18
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeCompositorSchedulerState {
    #[prost(message, optional, tag = "1")]
    pub state_machine: ::core::option::Option<ChromeCompositorStateMachine>,
    #[prost(bool, optional, tag = "2")]
    pub observing_begin_frame_source: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub begin_impl_frame_deadline_task: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub pending_begin_frame_task: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub skipped_last_frame_missed_exceeded_deadline: ::core::option::Option<bool>,
    #[prost(enumeration = "ChromeCompositorSchedulerAction", optional, tag = "7")]
    pub inside_action: ::core::option::Option<i32>,
    #[prost(
        enumeration = "chrome_compositor_scheduler_state::BeginImplFrameDeadlineMode",
        optional,
        tag = "8"
    )]
    pub deadline_mode: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "9")]
    pub deadline_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "10")]
    pub deadline_scheduled_at_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "11")]
    pub now_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "12")]
    pub now_to_deadline_delta_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "13")]
    pub now_to_deadline_scheduled_at_delta_us: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "14")]
    pub begin_impl_frame_args: ::core::option::Option<BeginImplFrameArgs>,
    #[prost(message, optional, tag = "15")]
    pub begin_frame_observer_state: ::core::option::Option<BeginFrameObserverState>,
    #[prost(message, optional, tag = "16")]
    pub begin_frame_source_state: ::core::option::Option<BeginFrameSourceState>,
    #[prost(message, optional, tag = "17")]
    pub compositor_timing_history: ::core::option::Option<CompositorTimingHistory>,
}
/// Nested message and enum types in `ChromeCompositorSchedulerState`.
pub mod chrome_compositor_scheduler_state {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BeginImplFrameDeadlineMode {
        DeadlineModeUnspecified = 0,
        DeadlineModeNone = 1,
        DeadlineModeImmediate = 2,
        DeadlineModeRegular = 3,
        DeadlineModeLate = 4,
        DeadlineModeBlocked = 5,
    }
    impl BeginImplFrameDeadlineMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DeadlineModeUnspecified => "DEADLINE_MODE_UNSPECIFIED",
                Self::DeadlineModeNone => "DEADLINE_MODE_NONE",
                Self::DeadlineModeImmediate => "DEADLINE_MODE_IMMEDIATE",
                Self::DeadlineModeRegular => "DEADLINE_MODE_REGULAR",
                Self::DeadlineModeLate => "DEADLINE_MODE_LATE",
                Self::DeadlineModeBlocked => "DEADLINE_MODE_BLOCKED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEADLINE_MODE_UNSPECIFIED" => Some(Self::DeadlineModeUnspecified),
                "DEADLINE_MODE_NONE" => Some(Self::DeadlineModeNone),
                "DEADLINE_MODE_IMMEDIATE" => Some(Self::DeadlineModeImmediate),
                "DEADLINE_MODE_REGULAR" => Some(Self::DeadlineModeRegular),
                "DEADLINE_MODE_LATE" => Some(Self::DeadlineModeLate),
                "DEADLINE_MODE_BLOCKED" => Some(Self::DeadlineModeBlocked),
                _ => None,
            }
        }
    }
}
/// Describes the current values stored in the Chrome Compositor state machine.
/// Next id: 3
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeCompositorStateMachine {
    #[prost(message, optional, tag = "1")]
    pub major_state: ::core::option::Option<chrome_compositor_state_machine::MajorState>,
    #[prost(message, optional, tag = "2")]
    pub minor_state: ::core::option::Option<chrome_compositor_state_machine::MinorState>,
}
/// Nested message and enum types in `ChromeCompositorStateMachine`.
pub mod chrome_compositor_state_machine {
    /// Next id: 6
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MajorState {
        #[prost(
            enumeration = "super::ChromeCompositorSchedulerAction",
            optional,
            tag = "1"
        )]
        pub next_action: ::core::option::Option<i32>,
        #[prost(enumeration = "major_state::BeginImplFrameState", optional, tag = "2")]
        pub begin_impl_frame_state: ::core::option::Option<i32>,
        #[prost(enumeration = "major_state::BeginMainFrameState", optional, tag = "3")]
        pub begin_main_frame_state: ::core::option::Option<i32>,
        #[prost(
            enumeration = "major_state::LayerTreeFrameSinkState",
            optional,
            tag = "4"
        )]
        pub layer_tree_frame_sink_state: ::core::option::Option<i32>,
        #[prost(
            enumeration = "major_state::ForcedRedrawOnTimeoutState",
            optional,
            tag = "5"
        )]
        pub forced_redraw_state: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `MajorState`.
    pub mod major_state {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum BeginImplFrameState {
            BeginImplFrameUnspecified = 0,
            BeginImplFrameIdle = 1,
            BeginImplFrameInsideBeginFrame = 2,
            BeginImplFrameInsideDeadline = 3,
        }
        impl BeginImplFrameState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::BeginImplFrameUnspecified => "BEGIN_IMPL_FRAME_UNSPECIFIED",
                    Self::BeginImplFrameIdle => "BEGIN_IMPL_FRAME_IDLE",
                    Self::BeginImplFrameInsideBeginFrame => {
                        "BEGIN_IMPL_FRAME_INSIDE_BEGIN_FRAME"
                    }
                    Self::BeginImplFrameInsideDeadline => {
                        "BEGIN_IMPL_FRAME_INSIDE_DEADLINE"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BEGIN_IMPL_FRAME_UNSPECIFIED" => {
                        Some(Self::BeginImplFrameUnspecified)
                    }
                    "BEGIN_IMPL_FRAME_IDLE" => Some(Self::BeginImplFrameIdle),
                    "BEGIN_IMPL_FRAME_INSIDE_BEGIN_FRAME" => {
                        Some(Self::BeginImplFrameInsideBeginFrame)
                    }
                    "BEGIN_IMPL_FRAME_INSIDE_DEADLINE" => {
                        Some(Self::BeginImplFrameInsideDeadline)
                    }
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum BeginMainFrameState {
            BeginMainFrameUnspecified = 0,
            BeginMainFrameIdle = 1,
            BeginMainFrameSent = 2,
            BeginMainFrameReadyToCommit = 3,
        }
        impl BeginMainFrameState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::BeginMainFrameUnspecified => "BEGIN_MAIN_FRAME_UNSPECIFIED",
                    Self::BeginMainFrameIdle => "BEGIN_MAIN_FRAME_IDLE",
                    Self::BeginMainFrameSent => "BEGIN_MAIN_FRAME_SENT",
                    Self::BeginMainFrameReadyToCommit => {
                        "BEGIN_MAIN_FRAME_READY_TO_COMMIT"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BEGIN_MAIN_FRAME_UNSPECIFIED" => {
                        Some(Self::BeginMainFrameUnspecified)
                    }
                    "BEGIN_MAIN_FRAME_IDLE" => Some(Self::BeginMainFrameIdle),
                    "BEGIN_MAIN_FRAME_SENT" => Some(Self::BeginMainFrameSent),
                    "BEGIN_MAIN_FRAME_READY_TO_COMMIT" => {
                        Some(Self::BeginMainFrameReadyToCommit)
                    }
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum LayerTreeFrameSinkState {
            LayerTreeFrameUnspecified = 0,
            LayerTreeFrameNone = 1,
            LayerTreeFrameActive = 2,
            LayerTreeFrameCreating = 3,
            LayerTreeFrameWaitingForFirstCommit = 4,
            LayerTreeFrameWaitingForFirstActivation = 5,
        }
        impl LayerTreeFrameSinkState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::LayerTreeFrameUnspecified => "LAYER_TREE_FRAME_UNSPECIFIED",
                    Self::LayerTreeFrameNone => "LAYER_TREE_FRAME_NONE",
                    Self::LayerTreeFrameActive => "LAYER_TREE_FRAME_ACTIVE",
                    Self::LayerTreeFrameCreating => "LAYER_TREE_FRAME_CREATING",
                    Self::LayerTreeFrameWaitingForFirstCommit => {
                        "LAYER_TREE_FRAME_WAITING_FOR_FIRST_COMMIT"
                    }
                    Self::LayerTreeFrameWaitingForFirstActivation => {
                        "LAYER_TREE_FRAME_WAITING_FOR_FIRST_ACTIVATION"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "LAYER_TREE_FRAME_UNSPECIFIED" => {
                        Some(Self::LayerTreeFrameUnspecified)
                    }
                    "LAYER_TREE_FRAME_NONE" => Some(Self::LayerTreeFrameNone),
                    "LAYER_TREE_FRAME_ACTIVE" => Some(Self::LayerTreeFrameActive),
                    "LAYER_TREE_FRAME_CREATING" => Some(Self::LayerTreeFrameCreating),
                    "LAYER_TREE_FRAME_WAITING_FOR_FIRST_COMMIT" => {
                        Some(Self::LayerTreeFrameWaitingForFirstCommit)
                    }
                    "LAYER_TREE_FRAME_WAITING_FOR_FIRST_ACTIVATION" => {
                        Some(Self::LayerTreeFrameWaitingForFirstActivation)
                    }
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ForcedRedrawOnTimeoutState {
            ForcedRedrawUnspecified = 0,
            ForcedRedrawIdle = 1,
            ForcedRedrawWaitingForCommit = 2,
            ForcedRedrawWaitingForActivation = 3,
            ForcedRedrawWaitingForDraw = 4,
        }
        impl ForcedRedrawOnTimeoutState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::ForcedRedrawUnspecified => "FORCED_REDRAW_UNSPECIFIED",
                    Self::ForcedRedrawIdle => "FORCED_REDRAW_IDLE",
                    Self::ForcedRedrawWaitingForCommit => {
                        "FORCED_REDRAW_WAITING_FOR_COMMIT"
                    }
                    Self::ForcedRedrawWaitingForActivation => {
                        "FORCED_REDRAW_WAITING_FOR_ACTIVATION"
                    }
                    Self::ForcedRedrawWaitingForDraw => "FORCED_REDRAW_WAITING_FOR_DRAW",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FORCED_REDRAW_UNSPECIFIED" => Some(Self::ForcedRedrawUnspecified),
                    "FORCED_REDRAW_IDLE" => Some(Self::ForcedRedrawIdle),
                    "FORCED_REDRAW_WAITING_FOR_COMMIT" => {
                        Some(Self::ForcedRedrawWaitingForCommit)
                    }
                    "FORCED_REDRAW_WAITING_FOR_ACTIVATION" => {
                        Some(Self::ForcedRedrawWaitingForActivation)
                    }
                    "FORCED_REDRAW_WAITING_FOR_DRAW" => {
                        Some(Self::ForcedRedrawWaitingForDraw)
                    }
                    _ => None,
                }
            }
        }
    }
    /// Next id: 47
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MinorState {
        #[prost(int32, optional, tag = "1")]
        pub commit_count: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub current_frame_number: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub last_frame_number_submit_performed: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub last_frame_number_draw_performed: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "5")]
        pub last_frame_number_begin_main_frame_sent: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "6")]
        pub did_draw: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "7")]
        pub did_send_begin_main_frame_for_current_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "8")]
        pub did_notify_begin_main_frame_not_expected_until: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "9")]
        pub did_notify_begin_main_frame_not_expected_soon: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "10")]
        pub wants_begin_main_frame_not_expected: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "11")]
        pub did_commit_during_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "12")]
        pub did_invalidate_layer_tree_frame_sink: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "13")]
        pub did_perform_impl_side_invalidaion: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "14")]
        pub did_prepare_tiles: ::core::option::Option<bool>,
        #[prost(int32, optional, tag = "15")]
        pub consecutive_checkerboard_animations: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "16")]
        pub pending_submit_frames: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "17")]
        pub submit_frames_with_current_layer_tree_frame_sink: ::core::option::Option<
            i32,
        >,
        #[prost(bool, optional, tag = "18")]
        pub needs_redraw: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "19")]
        pub needs_prepare_tiles: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "20")]
        pub needs_begin_main_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "21")]
        pub needs_one_begin_impl_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "22")]
        pub visible: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "23")]
        pub begin_frame_source_paused: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "24")]
        pub can_draw: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "25")]
        pub resourceless_draw: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "26")]
        pub has_pending_tree: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "27")]
        pub pending_tree_is_ready_for_activation: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "28")]
        pub active_tree_needs_first_draw: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "29")]
        pub active_tree_is_ready_to_draw: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "30")]
        pub did_create_and_initialize_first_layer_tree_frame_sink: ::core::option::Option<
            bool,
        >,
        #[prost(enumeration = "minor_state::TreePriority", optional, tag = "31")]
        pub tree_priority: ::core::option::Option<i32>,
        #[prost(enumeration = "minor_state::ScrollHandlerState", optional, tag = "32")]
        pub scroll_handler_state: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "33")]
        pub critical_begin_main_frame_to_activate_is_fast: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "34")]
        pub main_thread_missed_last_deadline: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "36")]
        pub video_needs_begin_frames: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "37")]
        pub defer_begin_main_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "38")]
        pub last_commit_had_no_updates: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "39")]
        pub did_draw_in_last_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "40")]
        pub did_submit_in_last_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "41")]
        pub needs_impl_side_invalidation: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "42")]
        pub current_pending_tree_is_impl_side: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "43")]
        pub previous_pending_tree_was_impl_side: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "44")]
        pub processing_animation_worklets_for_active_tree: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "45")]
        pub processing_animation_worklets_for_pending_tree: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "46")]
        pub processing_paint_worklets_for_pending_tree: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `MinorState`.
    pub mod minor_state {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TreePriority {
            Unspecified = 0,
            SamePriorityForBothTrees = 1,
            SmoothnessTakesPriority = 2,
            NewContentTakesPriority = 3,
        }
        impl TreePriority {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TREE_PRIORITY_UNSPECIFIED",
                    Self::SamePriorityForBothTrees => {
                        "TREE_PRIORITY_SAME_PRIORITY_FOR_BOTH_TREES"
                    }
                    Self::SmoothnessTakesPriority => {
                        "TREE_PRIORITY_SMOOTHNESS_TAKES_PRIORITY"
                    }
                    Self::NewContentTakesPriority => {
                        "TREE_PRIORITY_NEW_CONTENT_TAKES_PRIORITY"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TREE_PRIORITY_UNSPECIFIED" => Some(Self::Unspecified),
                    "TREE_PRIORITY_SAME_PRIORITY_FOR_BOTH_TREES" => {
                        Some(Self::SamePriorityForBothTrees)
                    }
                    "TREE_PRIORITY_SMOOTHNESS_TAKES_PRIORITY" => {
                        Some(Self::SmoothnessTakesPriority)
                    }
                    "TREE_PRIORITY_NEW_CONTENT_TAKES_PRIORITY" => {
                        Some(Self::NewContentTakesPriority)
                    }
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ScrollHandlerState {
            ScrollHandlerUnspecified = 0,
            ScrollAffectsScrollHandler = 1,
            ScrollDoesNotAffectScrollHandler = 2,
        }
        impl ScrollHandlerState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::ScrollHandlerUnspecified => "SCROLL_HANDLER_UNSPECIFIED",
                    Self::ScrollAffectsScrollHandler => "SCROLL_AFFECTS_SCROLL_HANDLER",
                    Self::ScrollDoesNotAffectScrollHandler => {
                        "SCROLL_DOES_NOT_AFFECT_SCROLL_HANDLER"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SCROLL_HANDLER_UNSPECIFIED" => Some(Self::ScrollHandlerUnspecified),
                    "SCROLL_AFFECTS_SCROLL_HANDLER" => {
                        Some(Self::ScrollAffectsScrollHandler)
                    }
                    "SCROLL_DOES_NOT_AFFECT_SCROLL_HANDLER" => {
                        Some(Self::ScrollDoesNotAffectScrollHandler)
                    }
                    _ => None,
                }
            }
        }
    }
}
/// Next id: 13
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginFrameArgs {
    #[prost(enumeration = "begin_frame_args::BeginFrameArgsType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub source_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub sequence_number: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "4")]
    pub frame_time_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub deadline_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub interval_delta_us: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "7")]
    pub on_critical_path: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub animate_only: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "12")]
    pub frames_throttled_since_last: ::core::option::Option<i64>,
    #[prost(oneof = "begin_frame_args::CreatedFrom", tags = "9, 10")]
    pub created_from: ::core::option::Option<begin_frame_args::CreatedFrom>,
}
/// Nested message and enum types in `BeginFrameArgs`.
pub mod begin_frame_args {
    /// JSON format has a "type" field that was always just "BeginFrameArgs" we
    /// drop this in the proto representation, and instead make the JSON format
    /// "subtype" field become the type field.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BeginFrameArgsType {
        Unspecified = 0,
        Invalid = 1,
        Normal = 2,
        Missed = 3,
    }
    impl BeginFrameArgsType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BEGIN_FRAME_ARGS_TYPE_UNSPECIFIED",
                Self::Invalid => "BEGIN_FRAME_ARGS_TYPE_INVALID",
                Self::Normal => "BEGIN_FRAME_ARGS_TYPE_NORMAL",
                Self::Missed => "BEGIN_FRAME_ARGS_TYPE_MISSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BEGIN_FRAME_ARGS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BEGIN_FRAME_ARGS_TYPE_INVALID" => Some(Self::Invalid),
                "BEGIN_FRAME_ARGS_TYPE_NORMAL" => Some(Self::Normal),
                "BEGIN_FRAME_ARGS_TYPE_MISSED" => Some(Self::Missed),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CreatedFrom {
        /// The interned SourceLocation.
        #[prost(uint64, tag = "9")]
        SourceLocationIid(u64),
        /// The SourceLocation that this args was created from.
        /// TODO(nuskos): Eventually we will support interning inside of
        /// TypedArgument TraceEvents and then we shouldn't need this SourceLocation
        /// since we can emit it as part of the InternedData message. When we can
        /// remove this |source_location|.
        #[prost(message, tag = "10")]
        SourceLocation(super::SourceLocation),
    }
}
/// Next id: 7
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginImplFrameArgs {
    #[prost(int64, optional, tag = "1")]
    pub updated_at_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub finished_at_us: ::core::option::Option<i64>,
    #[prost(enumeration = "begin_impl_frame_args::State", optional, tag = "3")]
    pub state: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "6")]
    pub timestamps_in_us: ::core::option::Option<begin_impl_frame_args::TimestampsInUs>,
    #[prost(oneof = "begin_impl_frame_args::Args", tags = "4, 5")]
    pub args: ::core::option::Option<begin_impl_frame_args::Args>,
}
/// Nested message and enum types in `BeginImplFrameArgs`.
pub mod begin_impl_frame_args {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TimestampsInUs {
        #[prost(int64, optional, tag = "1")]
        pub interval_delta: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "2")]
        pub now_to_deadline_delta: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "3")]
        pub frame_time_to_now_delta: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "4")]
        pub frame_time_to_deadline_delta: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "5")]
        pub now: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "6")]
        pub frame_time: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "7")]
        pub deadline: ::core::option::Option<i64>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        BeginFrameFinished = 0,
        BeginFrameUsing = 1,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::BeginFrameFinished => "BEGIN_FRAME_FINISHED",
                Self::BeginFrameUsing => "BEGIN_FRAME_USING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BEGIN_FRAME_FINISHED" => Some(Self::BeginFrameFinished),
                "BEGIN_FRAME_USING" => Some(Self::BeginFrameUsing),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Args {
        /// Only set if |state| is BEGIN_FRAME_FINISHED.
        #[prost(message, tag = "4")]
        CurrentArgs(super::BeginFrameArgs),
        /// Only set if |state| is BEGIN_FRAME_USING.
        #[prost(message, tag = "5")]
        LastArgs(super::BeginFrameArgs),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginFrameObserverState {
    #[prost(int64, optional, tag = "1")]
    pub dropped_begin_frame_args: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub last_begin_frame_args: ::core::option::Option<BeginFrameArgs>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginFrameSourceState {
    #[prost(uint32, optional, tag = "1")]
    pub source_id: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "2")]
    pub paused: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "3")]
    pub num_observers: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub last_begin_frame_args: ::core::option::Option<BeginFrameArgs>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompositorTimingHistory {
    #[prost(int64, optional, tag = "1")]
    pub begin_main_frame_queue_critical_estimate_delta_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub begin_main_frame_queue_not_critical_estimate_delta_us: ::core::option::Option<
        i64,
    >,
    #[prost(int64, optional, tag = "3")]
    pub begin_main_frame_start_to_ready_to_commit_estimate_delta_us: ::core::option::Option<
        i64,
    >,
    #[prost(int64, optional, tag = "4")]
    pub commit_to_ready_to_activate_estimate_delta_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub prepare_tiles_estimate_delta_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub activate_estimate_delta_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub draw_estimate_delta_us: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChromeCompositorSchedulerAction {
    CcSchedulerActionUnspecified = 0,
    CcSchedulerActionNone = 1,
    CcSchedulerActionSendBeginMainFrame = 2,
    CcSchedulerActionCommit = 3,
    CcSchedulerActionActivateSyncTree = 4,
    CcSchedulerActionDrawIfPossible = 5,
    CcSchedulerActionDrawForced = 6,
    CcSchedulerActionDrawAbort = 7,
    CcSchedulerActionBeginLayerTreeFrameSinkCreation = 8,
    CcSchedulerActionPrepareTiles = 9,
    CcSchedulerActionInvalidateLayerTreeFrameSink = 10,
    CcSchedulerActionPerformImplSideInvalidation = 11,
    CcSchedulerActionNotifyBeginMainFrameNotExpectedUntil = 12,
    CcSchedulerActionNotifyBeginMainFrameNotExpectedSoon = 13,
}
impl ChromeCompositorSchedulerAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CcSchedulerActionUnspecified => "CC_SCHEDULER_ACTION_UNSPECIFIED",
            Self::CcSchedulerActionNone => "CC_SCHEDULER_ACTION_NONE",
            Self::CcSchedulerActionSendBeginMainFrame => {
                "CC_SCHEDULER_ACTION_SEND_BEGIN_MAIN_FRAME"
            }
            Self::CcSchedulerActionCommit => "CC_SCHEDULER_ACTION_COMMIT",
            Self::CcSchedulerActionActivateSyncTree => {
                "CC_SCHEDULER_ACTION_ACTIVATE_SYNC_TREE"
            }
            Self::CcSchedulerActionDrawIfPossible => {
                "CC_SCHEDULER_ACTION_DRAW_IF_POSSIBLE"
            }
            Self::CcSchedulerActionDrawForced => "CC_SCHEDULER_ACTION_DRAW_FORCED",
            Self::CcSchedulerActionDrawAbort => "CC_SCHEDULER_ACTION_DRAW_ABORT",
            Self::CcSchedulerActionBeginLayerTreeFrameSinkCreation => {
                "CC_SCHEDULER_ACTION_BEGIN_LAYER_TREE_FRAME_SINK_CREATION"
            }
            Self::CcSchedulerActionPrepareTiles => "CC_SCHEDULER_ACTION_PREPARE_TILES",
            Self::CcSchedulerActionInvalidateLayerTreeFrameSink => {
                "CC_SCHEDULER_ACTION_INVALIDATE_LAYER_TREE_FRAME_SINK"
            }
            Self::CcSchedulerActionPerformImplSideInvalidation => {
                "CC_SCHEDULER_ACTION_PERFORM_IMPL_SIDE_INVALIDATION"
            }
            Self::CcSchedulerActionNotifyBeginMainFrameNotExpectedUntil => {
                "CC_SCHEDULER_ACTION_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL"
            }
            Self::CcSchedulerActionNotifyBeginMainFrameNotExpectedSoon => {
                "CC_SCHEDULER_ACTION_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CC_SCHEDULER_ACTION_UNSPECIFIED" => Some(Self::CcSchedulerActionUnspecified),
            "CC_SCHEDULER_ACTION_NONE" => Some(Self::CcSchedulerActionNone),
            "CC_SCHEDULER_ACTION_SEND_BEGIN_MAIN_FRAME" => {
                Some(Self::CcSchedulerActionSendBeginMainFrame)
            }
            "CC_SCHEDULER_ACTION_COMMIT" => Some(Self::CcSchedulerActionCommit),
            "CC_SCHEDULER_ACTION_ACTIVATE_SYNC_TREE" => {
                Some(Self::CcSchedulerActionActivateSyncTree)
            }
            "CC_SCHEDULER_ACTION_DRAW_IF_POSSIBLE" => {
                Some(Self::CcSchedulerActionDrawIfPossible)
            }
            "CC_SCHEDULER_ACTION_DRAW_FORCED" => Some(Self::CcSchedulerActionDrawForced),
            "CC_SCHEDULER_ACTION_DRAW_ABORT" => Some(Self::CcSchedulerActionDrawAbort),
            "CC_SCHEDULER_ACTION_BEGIN_LAYER_TREE_FRAME_SINK_CREATION" => {
                Some(Self::CcSchedulerActionBeginLayerTreeFrameSinkCreation)
            }
            "CC_SCHEDULER_ACTION_PREPARE_TILES" => {
                Some(Self::CcSchedulerActionPrepareTiles)
            }
            "CC_SCHEDULER_ACTION_INVALIDATE_LAYER_TREE_FRAME_SINK" => {
                Some(Self::CcSchedulerActionInvalidateLayerTreeFrameSink)
            }
            "CC_SCHEDULER_ACTION_PERFORM_IMPL_SIDE_INVALIDATION" => {
                Some(Self::CcSchedulerActionPerformImplSideInvalidation)
            }
            "CC_SCHEDULER_ACTION_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL" => {
                Some(Self::CcSchedulerActionNotifyBeginMainFrameNotExpectedUntil)
            }
            "CC_SCHEDULER_ACTION_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON" => {
                Some(Self::CcSchedulerActionNotifyBeginMainFrameNotExpectedSoon)
            }
            _ => None,
        }
    }
}
/// Details about ContentSettings trace events.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeContentSettingsEventInfo {
    /// The number of user defined hostname patterns for content settings at
    /// browser start. Similar to UMA histogram
    /// 'ContentSettings.NumberOfExceptions'.
    #[prost(uint32, optional, tag = "1")]
    pub number_of_exceptions: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeFrameReporter {
    #[prost(enumeration = "chrome_frame_reporter::State", optional, tag = "1")]
    pub state: ::core::option::Option<i32>,
    /// The reason is set only if |state| is not |STATE_UPDATED_ALL|.
    #[prost(enumeration = "chrome_frame_reporter::FrameDropReason", optional, tag = "2")]
    pub reason: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3")]
    pub frame_source: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub frame_sequence: ::core::option::Option<u64>,
    /// If this is a droped frame (i.e. if |state| is set to |STATE_DROPPED| or
    /// |STATE_PRESENTED_PARTIAL|), then indicates whether this frame impacts
    /// smoothness.
    #[prost(bool, optional, tag = "5")]
    pub affects_smoothness: ::core::option::Option<bool>,
    /// The type of active scroll.
    #[prost(enumeration = "chrome_frame_reporter::ScrollState", optional, tag = "6")]
    pub scroll_state: ::core::option::Option<i32>,
    /// If any main thread animation is active during this frame.
    #[prost(bool, optional, tag = "7")]
    pub has_main_animation: ::core::option::Option<bool>,
    /// If any compositor thread animation is active during this frame.
    #[prost(bool, optional, tag = "8")]
    pub has_compositor_animation: ::core::option::Option<bool>,
    /// If any touch-driven UX (not scroll) is active during this frame.
    #[prost(bool, optional, tag = "9")]
    pub has_smooth_input_main: ::core::option::Option<bool>,
    /// Whether the frame contained any missing content (i.e. whether there was
    /// checkerboarding in the frame).  If has_missing_content,
    /// checkerboarded_needs_raster and checkerboarded_needs_record all have
    /// values, has_missing_content should equal checkerboarded_needs_raster ||
    /// checkerboarded_needs_record.
    #[prost(bool, optional, tag = "10")]
    pub has_missing_content: ::core::option::Option<bool>,
    /// The id of layer_tree_host that the frame has been produced for.
    #[prost(uint64, optional, tag = "11")]
    pub layer_tree_host_id: ::core::option::Option<u64>,
    /// If total latency of PipelineReporter exceeds a certain limit.
    #[prost(bool, optional, tag = "12")]
    pub has_high_latency: ::core::option::Option<bool>,
    /// Indicate if the frame is "FORKED" (i.e. a PipelineReporter event starts at
    /// the same frame sequence as another PipelineReporter) or "BACKFILL"
    /// (i.e. dropped frames when there are no partial compositor updates).
    #[prost(enumeration = "chrome_frame_reporter::FrameType", optional, tag = "13")]
    pub frame_type: ::core::option::Option<i32>,
    /// The breakdown stage of PipelineReporter that is most likely accountable for
    /// high latency.
    #[prost(string, repeated, tag = "14")]
    pub high_latency_contribution_stage: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Whether the frame contained any content that is not fully rastered.
    #[prost(bool, optional, tag = "15")]
    pub checkerboarded_needs_raster: ::core::option::Option<bool>,
    /// Whether the frame contained any content that is not fully recorded.
    #[prost(bool, optional, tag = "16")]
    pub checkerboarded_needs_record: ::core::option::Option<bool>,
    /// viz::BeginFrameArgs.trace_id of the frame (before surface aggregation). See
    /// also ChromeTrackEvent.EventLatency.surface_frame_trace_id.
    #[prost(int64, optional, tag = "17")]
    pub surface_frame_trace_id: ::core::option::Option<i64>,
    /// gfx::PresentationFeedback.display_trace_id of the frame (after surface
    /// aggregation). See also ChromeTrackEvent.EventLatency.display_trace_id.
    #[prost(int64, optional, tag = "18")]
    pub display_trace_id: ::core::option::Option<i64>,
}
/// Nested message and enum types in `ChromeFrameReporter`.
pub mod chrome_frame_reporter {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The frame did not have any updates to present.
        NoUpdateDesired = 0,
        /// The frame presented all the desired updates (i.e. any updates requested
        /// from both the compositor thread and main-threads were handled).
        PresentedAll = 1,
        /// The frame was presented with some updates, but also missed some updates
        /// (e.g. missed updates from the main-thread, but included updates from the
        /// compositor thread).
        PresentedPartial = 2,
        /// The frame was dropped, i.e. some updates were desired for the frame, but
        /// was not presented.
        Dropped = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NoUpdateDesired => "STATE_NO_UPDATE_DESIRED",
                Self::PresentedAll => "STATE_PRESENTED_ALL",
                Self::PresentedPartial => "STATE_PRESENTED_PARTIAL",
                Self::Dropped => "STATE_DROPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_NO_UPDATE_DESIRED" => Some(Self::NoUpdateDesired),
                "STATE_PRESENTED_ALL" => Some(Self::PresentedAll),
                "STATE_PRESENTED_PARTIAL" => Some(Self::PresentedPartial),
                "STATE_DROPPED" => Some(Self::Dropped),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrameDropReason {
        ReasonUnspecified = 0,
        /// Frame was dropped by the display-compositor.
        /// The display-compositor may drop a frame some times (e.g. the frame missed
        /// the deadline, or was blocked on surface-sync, etc.)
        ReasonDisplayCompositor = 1,
        /// Frame was dropped because of the main-thread.
        /// The main-thread may cause a frame to be dropped, e.g. if the main-thread
        /// is running expensive javascript, or doing a lot of layout updates, etc.
        ReasonMainThread = 2,
        /// Frame was dropped by the client compositor.
        /// The client compositor can drop some frames too (e.g. attempting to
        /// recover latency, missing the deadline, etc.).
        ReasonClientCompositor = 3,
    }
    impl FrameDropReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ReasonUnspecified => "REASON_UNSPECIFIED",
                Self::ReasonDisplayCompositor => "REASON_DISPLAY_COMPOSITOR",
                Self::ReasonMainThread => "REASON_MAIN_THREAD",
                Self::ReasonClientCompositor => "REASON_CLIENT_COMPOSITOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_UNSPECIFIED" => Some(Self::ReasonUnspecified),
                "REASON_DISPLAY_COMPOSITOR" => Some(Self::ReasonDisplayCompositor),
                "REASON_MAIN_THREAD" => Some(Self::ReasonMainThread),
                "REASON_CLIENT_COMPOSITOR" => Some(Self::ReasonClientCompositor),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ScrollState {
        ScrollNone = 0,
        ScrollMainThread = 1,
        ScrollCompositorThread = 2,
        ScrollRaster = 3,
        /// Used when it can't be determined whether a scroll is in progress or not.
        ScrollUnknown = 4,
    }
    impl ScrollState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ScrollNone => "SCROLL_NONE",
                Self::ScrollMainThread => "SCROLL_MAIN_THREAD",
                Self::ScrollCompositorThread => "SCROLL_COMPOSITOR_THREAD",
                Self::ScrollRaster => "SCROLL_RASTER",
                Self::ScrollUnknown => "SCROLL_UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCROLL_NONE" => Some(Self::ScrollNone),
                "SCROLL_MAIN_THREAD" => Some(Self::ScrollMainThread),
                "SCROLL_COMPOSITOR_THREAD" => Some(Self::ScrollCompositorThread),
                "SCROLL_RASTER" => Some(Self::ScrollRaster),
                "SCROLL_UNKNOWN" => Some(Self::ScrollUnknown),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrameType {
        Forked = 0,
        Backfill = 1,
    }
    impl FrameType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Forked => "FORKED",
                Self::Backfill => "BACKFILL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORKED" => Some(Self::Forked),
                "BACKFILL" => Some(Self::Backfill),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistogramName {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
/// An individual histogram sample logged via Chrome's UMA metrics system.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeHistogramSample {
    /// MD5 hash of the metric name. Either |name_hash| or |name|/|name_iid| or
    /// both must be present.
    #[prost(uint64, optional, tag = "1")]
    pub name_hash: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "3")]
    pub sample: ::core::option::Option<i64>,
    /// Interned HistogramName. Only one of |name|, |name_iid| can be set.
    #[prost(uint64, optional, tag = "4")]
    pub name_iid: ::core::option::Option<u64>,
}
/// Details about one of Chrome's keyed services associated with the event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeKeyedService {
    /// Name of the service, e.g. "MediaRouter", "PreviewsService", etc. (in
    /// Chrome, these are static strings known at compile time).
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeLatencyInfo {
    #[prost(int64, optional, tag = "1")]
    pub trace_id: ::core::option::Option<i64>,
    #[prost(enumeration = "chrome_latency_info::Step", optional, tag = "2")]
    pub step: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub frame_tree_node_id: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "4")]
    pub component_info: ::prost::alloc::vec::Vec<chrome_latency_info::ComponentInfo>,
    #[prost(bool, optional, tag = "5")]
    pub is_coalesced: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "6")]
    pub gesture_scroll_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub touch_id: ::core::option::Option<i64>,
    /// The type of input corresponding to this `ChromeLatencyInfo`.
    #[prost(enumeration = "chrome_latency_info::InputType", optional, tag = "8")]
    pub input_type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ChromeLatencyInfo`.
pub mod chrome_latency_info {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ComponentInfo {
        #[prost(enumeration = "LatencyComponentType", optional, tag = "1")]
        pub component_type: ::core::option::Option<i32>,
        /// Microsecond timestamp in CLOCK_MONOTONIC domain
        #[prost(uint64, optional, tag = "2")]
        pub time_us: ::core::option::Option<u64>,
    }
    /// NEXT ID: 12
    /// All step are optional but the enum is ordered (not by number) below in the
    /// order we expect them to appear if they are emitted in trace in a blocking
    /// fashion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Step {
        Unspecified = 0,
        /// Emitted on the browser main thread.
        SendInputEventUi = 3,
        /// Happens on the renderer's compositor.
        HandleInputEventImpl = 5,
        DidHandleInputAndOverscroll = 8,
        /// Occurs on the Renderer's main thread.
        HandleInputEventMain = 4,
        MainThreadScrollUpdate = 2,
        HandleInputEventMainCommit = 1,
        /// Could be emitted on both the renderer's main OR compositor.
        HandledInputEventMainOrImpl = 9,
        /// Optionally sometimes HANDLED_INPUT_EVENT_MAIN_OR_IMPL will proxy to the
        /// renderer's compositor and this will be emitted.
        HandledInputEventImpl = 10,
        /// Renderer's compositor.
        SwapBuffers = 6,
        /// Happens on the VizCompositor in the GPU process.
        DrawAndSwap = 7,
        /// Happens on the GPU main thread after the swap has completed.
        ///
        /// See above for NEXT ID, enum steps are not ordered by tag number.
        FinishedSwapBuffers = 11,
    }
    impl Step {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STEP_UNSPECIFIED",
                Self::SendInputEventUi => "STEP_SEND_INPUT_EVENT_UI",
                Self::HandleInputEventImpl => "STEP_HANDLE_INPUT_EVENT_IMPL",
                Self::DidHandleInputAndOverscroll => {
                    "STEP_DID_HANDLE_INPUT_AND_OVERSCROLL"
                }
                Self::HandleInputEventMain => "STEP_HANDLE_INPUT_EVENT_MAIN",
                Self::MainThreadScrollUpdate => "STEP_MAIN_THREAD_SCROLL_UPDATE",
                Self::HandleInputEventMainCommit => "STEP_HANDLE_INPUT_EVENT_MAIN_COMMIT",
                Self::HandledInputEventMainOrImpl => {
                    "STEP_HANDLED_INPUT_EVENT_MAIN_OR_IMPL"
                }
                Self::HandledInputEventImpl => "STEP_HANDLED_INPUT_EVENT_IMPL",
                Self::SwapBuffers => "STEP_SWAP_BUFFERS",
                Self::DrawAndSwap => "STEP_DRAW_AND_SWAP",
                Self::FinishedSwapBuffers => "STEP_FINISHED_SWAP_BUFFERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STEP_UNSPECIFIED" => Some(Self::Unspecified),
                "STEP_SEND_INPUT_EVENT_UI" => Some(Self::SendInputEventUi),
                "STEP_HANDLE_INPUT_EVENT_IMPL" => Some(Self::HandleInputEventImpl),
                "STEP_DID_HANDLE_INPUT_AND_OVERSCROLL" => {
                    Some(Self::DidHandleInputAndOverscroll)
                }
                "STEP_HANDLE_INPUT_EVENT_MAIN" => Some(Self::HandleInputEventMain),
                "STEP_MAIN_THREAD_SCROLL_UPDATE" => Some(Self::MainThreadScrollUpdate),
                "STEP_HANDLE_INPUT_EVENT_MAIN_COMMIT" => {
                    Some(Self::HandleInputEventMainCommit)
                }
                "STEP_HANDLED_INPUT_EVENT_MAIN_OR_IMPL" => {
                    Some(Self::HandledInputEventMainOrImpl)
                }
                "STEP_HANDLED_INPUT_EVENT_IMPL" => Some(Self::HandledInputEventImpl),
                "STEP_SWAP_BUFFERS" => Some(Self::SwapBuffers),
                "STEP_DRAW_AND_SWAP" => Some(Self::DrawAndSwap),
                "STEP_FINISHED_SWAP_BUFFERS" => Some(Self::FinishedSwapBuffers),
                _ => None,
            }
        }
    }
    /// This enum is a copy of LatencyComponentType enum in Chrome, located in
    /// ui/latency/latency_info.h, modulo added UNKNOWN value per protobuf
    /// practices.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LatencyComponentType {
        ComponentUnspecified = 0,
        ComponentInputEventLatencyBeginRwh = 1,
        ComponentInputEventLatencyScrollUpdateOriginal = 2,
        ComponentInputEventLatencyFirstScrollUpdateOriginal = 3,
        ComponentInputEventLatencyOriginal = 4,
        ComponentInputEventLatencyUi = 5,
        ComponentInputEventLatencyRendererMain = 6,
        ComponentInputEventLatencyRenderingScheduledMain = 7,
        ComponentInputEventLatencyRenderingScheduledImpl = 8,
        ComponentInputEventLatencyScrollUpdateLastEvent = 9,
        ComponentInputEventLatencyAckRwh = 10,
        ComponentInputEventLatencyRendererSwap = 11,
        ComponentDisplayCompositorReceivedFrame = 12,
        ComponentInputEventGpuSwapBuffer = 13,
        ComponentInputEventLatencyFrameSwap = 14,
    }
    impl LatencyComponentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ComponentUnspecified => "COMPONENT_UNSPECIFIED",
                Self::ComponentInputEventLatencyBeginRwh => {
                    "COMPONENT_INPUT_EVENT_LATENCY_BEGIN_RWH"
                }
                Self::ComponentInputEventLatencyScrollUpdateOriginal => {
                    "COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL"
                }
                Self::ComponentInputEventLatencyFirstScrollUpdateOriginal => {
                    "COMPONENT_INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL"
                }
                Self::ComponentInputEventLatencyOriginal => {
                    "COMPONENT_INPUT_EVENT_LATENCY_ORIGINAL"
                }
                Self::ComponentInputEventLatencyUi => "COMPONENT_INPUT_EVENT_LATENCY_UI",
                Self::ComponentInputEventLatencyRendererMain => {
                    "COMPONENT_INPUT_EVENT_LATENCY_RENDERER_MAIN"
                }
                Self::ComponentInputEventLatencyRenderingScheduledMain => {
                    "COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN"
                }
                Self::ComponentInputEventLatencyRenderingScheduledImpl => {
                    "COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL"
                }
                Self::ComponentInputEventLatencyScrollUpdateLastEvent => {
                    "COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_LAST_EVENT"
                }
                Self::ComponentInputEventLatencyAckRwh => {
                    "COMPONENT_INPUT_EVENT_LATENCY_ACK_RWH"
                }
                Self::ComponentInputEventLatencyRendererSwap => {
                    "COMPONENT_INPUT_EVENT_LATENCY_RENDERER_SWAP"
                }
                Self::ComponentDisplayCompositorReceivedFrame => {
                    "COMPONENT_DISPLAY_COMPOSITOR_RECEIVED_FRAME"
                }
                Self::ComponentInputEventGpuSwapBuffer => {
                    "COMPONENT_INPUT_EVENT_GPU_SWAP_BUFFER"
                }
                Self::ComponentInputEventLatencyFrameSwap => {
                    "COMPONENT_INPUT_EVENT_LATENCY_FRAME_SWAP"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPONENT_UNSPECIFIED" => Some(Self::ComponentUnspecified),
                "COMPONENT_INPUT_EVENT_LATENCY_BEGIN_RWH" => {
                    Some(Self::ComponentInputEventLatencyBeginRwh)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL" => {
                    Some(Self::ComponentInputEventLatencyScrollUpdateOriginal)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL" => {
                    Some(Self::ComponentInputEventLatencyFirstScrollUpdateOriginal)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_ORIGINAL" => {
                    Some(Self::ComponentInputEventLatencyOriginal)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_UI" => {
                    Some(Self::ComponentInputEventLatencyUi)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_RENDERER_MAIN" => {
                    Some(Self::ComponentInputEventLatencyRendererMain)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN" => {
                    Some(Self::ComponentInputEventLatencyRenderingScheduledMain)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL" => {
                    Some(Self::ComponentInputEventLatencyRenderingScheduledImpl)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_LAST_EVENT" => {
                    Some(Self::ComponentInputEventLatencyScrollUpdateLastEvent)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_ACK_RWH" => {
                    Some(Self::ComponentInputEventLatencyAckRwh)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_RENDERER_SWAP" => {
                    Some(Self::ComponentInputEventLatencyRendererSwap)
                }
                "COMPONENT_DISPLAY_COMPOSITOR_RECEIVED_FRAME" => {
                    Some(Self::ComponentDisplayCompositorReceivedFrame)
                }
                "COMPONENT_INPUT_EVENT_GPU_SWAP_BUFFER" => {
                    Some(Self::ComponentInputEventGpuSwapBuffer)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_FRAME_SWAP" => {
                    Some(Self::ComponentInputEventLatencyFrameSwap)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InputType {
        UnspecifiedOrOther = 0,
        TouchMoved = 1,
        GestureScrollBegin = 2,
        GestureScrollUpdate = 3,
        GestureScrollEnd = 4,
        GestureTap = 5,
        GestureTapCancel = 6,
    }
    impl InputType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnspecifiedOrOther => "UNSPECIFIED_OR_OTHER",
                Self::TouchMoved => "TOUCH_MOVED",
                Self::GestureScrollBegin => "GESTURE_SCROLL_BEGIN",
                Self::GestureScrollUpdate => "GESTURE_SCROLL_UPDATE",
                Self::GestureScrollEnd => "GESTURE_SCROLL_END",
                Self::GestureTap => "GESTURE_TAP",
                Self::GestureTapCancel => "GESTURE_TAP_CANCEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED_OR_OTHER" => Some(Self::UnspecifiedOrOther),
                "TOUCH_MOVED" => Some(Self::TouchMoved),
                "GESTURE_SCROLL_BEGIN" => Some(Self::GestureScrollBegin),
                "GESTURE_SCROLL_UPDATE" => Some(Self::GestureScrollUpdate),
                "GESTURE_SCROLL_END" => Some(Self::GestureScrollEnd),
                "GESTURE_TAP" => Some(Self::GestureTap),
                "GESTURE_TAP_CANCEL" => Some(Self::GestureTapCancel),
                _ => None,
            }
        }
    }
}
/// Details about a legacy Chrome IPC message that is either sent by the event.
/// TODO(eseckler): Also use this message on the receiving side?
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeLegacyIpc {
    /// Corresponds to the message class type defined in Chrome's IPCMessageStart
    /// enum, e.g. FrameMsgStart,
    #[prost(enumeration = "chrome_legacy_ipc::MessageClass", optional, tag = "1")]
    pub message_class: ::core::option::Option<i32>,
    /// Line number of the message definition. See Chrome's IPC_MESSAGE_ID and
    /// IPC_MESSAGE_START macros.
    #[prost(uint32, optional, tag = "2")]
    pub message_line: ::core::option::Option<u32>,
}
/// Nested message and enum types in `ChromeLegacyIpc`.
pub mod chrome_legacy_ipc {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MessageClass {
        ClassUnspecified = 0,
        ClassAutomation = 1,
        ClassFrame = 2,
        ClassPage = 3,
        ClassView = 4,
        ClassWidget = 5,
        ClassInput = 6,
        ClassTest = 7,
        ClassWorker = 8,
        ClassNacl = 9,
        ClassGpuChannel = 10,
        ClassMedia = 11,
        ClassPpapi = 12,
        ClassChrome = 13,
        ClassDrag = 14,
        ClassPrint = 15,
        ClassExtension = 16,
        ClassTextInputClient = 17,
        ClassBlinkTest = 18,
        ClassAccessibility = 19,
        ClassPrerender = 20,
        ClassChromoting = 21,
        ClassBrowserPlugin = 22,
        ClassAndroidWebView = 23,
        ClassNaclHost = 24,
        ClassEncryptedMedia = 25,
        ClassCast = 26,
        ClassGinJavaBridge = 27,
        ClassChromeUtilityPrinting = 28,
        ClassOzoneGpu = 29,
        ClassWebTest = 30,
        ClassNetworkHints = 31,
        ClassExtensionsGuestView = 32,
        ClassGuestView = 33,
        ClassMediaPlayerDelegate = 34,
        ClassExtensionWorker = 35,
        ClassSubresourceFilter = 36,
        ClassUnfreezableFrame = 37,
    }
    impl MessageClass {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ClassUnspecified => "CLASS_UNSPECIFIED",
                Self::ClassAutomation => "CLASS_AUTOMATION",
                Self::ClassFrame => "CLASS_FRAME",
                Self::ClassPage => "CLASS_PAGE",
                Self::ClassView => "CLASS_VIEW",
                Self::ClassWidget => "CLASS_WIDGET",
                Self::ClassInput => "CLASS_INPUT",
                Self::ClassTest => "CLASS_TEST",
                Self::ClassWorker => "CLASS_WORKER",
                Self::ClassNacl => "CLASS_NACL",
                Self::ClassGpuChannel => "CLASS_GPU_CHANNEL",
                Self::ClassMedia => "CLASS_MEDIA",
                Self::ClassPpapi => "CLASS_PPAPI",
                Self::ClassChrome => "CLASS_CHROME",
                Self::ClassDrag => "CLASS_DRAG",
                Self::ClassPrint => "CLASS_PRINT",
                Self::ClassExtension => "CLASS_EXTENSION",
                Self::ClassTextInputClient => "CLASS_TEXT_INPUT_CLIENT",
                Self::ClassBlinkTest => "CLASS_BLINK_TEST",
                Self::ClassAccessibility => "CLASS_ACCESSIBILITY",
                Self::ClassPrerender => "CLASS_PRERENDER",
                Self::ClassChromoting => "CLASS_CHROMOTING",
                Self::ClassBrowserPlugin => "CLASS_BROWSER_PLUGIN",
                Self::ClassAndroidWebView => "CLASS_ANDROID_WEB_VIEW",
                Self::ClassNaclHost => "CLASS_NACL_HOST",
                Self::ClassEncryptedMedia => "CLASS_ENCRYPTED_MEDIA",
                Self::ClassCast => "CLASS_CAST",
                Self::ClassGinJavaBridge => "CLASS_GIN_JAVA_BRIDGE",
                Self::ClassChromeUtilityPrinting => "CLASS_CHROME_UTILITY_PRINTING",
                Self::ClassOzoneGpu => "CLASS_OZONE_GPU",
                Self::ClassWebTest => "CLASS_WEB_TEST",
                Self::ClassNetworkHints => "CLASS_NETWORK_HINTS",
                Self::ClassExtensionsGuestView => "CLASS_EXTENSIONS_GUEST_VIEW",
                Self::ClassGuestView => "CLASS_GUEST_VIEW",
                Self::ClassMediaPlayerDelegate => "CLASS_MEDIA_PLAYER_DELEGATE",
                Self::ClassExtensionWorker => "CLASS_EXTENSION_WORKER",
                Self::ClassSubresourceFilter => "CLASS_SUBRESOURCE_FILTER",
                Self::ClassUnfreezableFrame => "CLASS_UNFREEZABLE_FRAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLASS_UNSPECIFIED" => Some(Self::ClassUnspecified),
                "CLASS_AUTOMATION" => Some(Self::ClassAutomation),
                "CLASS_FRAME" => Some(Self::ClassFrame),
                "CLASS_PAGE" => Some(Self::ClassPage),
                "CLASS_VIEW" => Some(Self::ClassView),
                "CLASS_WIDGET" => Some(Self::ClassWidget),
                "CLASS_INPUT" => Some(Self::ClassInput),
                "CLASS_TEST" => Some(Self::ClassTest),
                "CLASS_WORKER" => Some(Self::ClassWorker),
                "CLASS_NACL" => Some(Self::ClassNacl),
                "CLASS_GPU_CHANNEL" => Some(Self::ClassGpuChannel),
                "CLASS_MEDIA" => Some(Self::ClassMedia),
                "CLASS_PPAPI" => Some(Self::ClassPpapi),
                "CLASS_CHROME" => Some(Self::ClassChrome),
                "CLASS_DRAG" => Some(Self::ClassDrag),
                "CLASS_PRINT" => Some(Self::ClassPrint),
                "CLASS_EXTENSION" => Some(Self::ClassExtension),
                "CLASS_TEXT_INPUT_CLIENT" => Some(Self::ClassTextInputClient),
                "CLASS_BLINK_TEST" => Some(Self::ClassBlinkTest),
                "CLASS_ACCESSIBILITY" => Some(Self::ClassAccessibility),
                "CLASS_PRERENDER" => Some(Self::ClassPrerender),
                "CLASS_CHROMOTING" => Some(Self::ClassChromoting),
                "CLASS_BROWSER_PLUGIN" => Some(Self::ClassBrowserPlugin),
                "CLASS_ANDROID_WEB_VIEW" => Some(Self::ClassAndroidWebView),
                "CLASS_NACL_HOST" => Some(Self::ClassNaclHost),
                "CLASS_ENCRYPTED_MEDIA" => Some(Self::ClassEncryptedMedia),
                "CLASS_CAST" => Some(Self::ClassCast),
                "CLASS_GIN_JAVA_BRIDGE" => Some(Self::ClassGinJavaBridge),
                "CLASS_CHROME_UTILITY_PRINTING" => Some(Self::ClassChromeUtilityPrinting),
                "CLASS_OZONE_GPU" => Some(Self::ClassOzoneGpu),
                "CLASS_WEB_TEST" => Some(Self::ClassWebTest),
                "CLASS_NETWORK_HINTS" => Some(Self::ClassNetworkHints),
                "CLASS_EXTENSIONS_GUEST_VIEW" => Some(Self::ClassExtensionsGuestView),
                "CLASS_GUEST_VIEW" => Some(Self::ClassGuestView),
                "CLASS_MEDIA_PLAYER_DELEGATE" => Some(Self::ClassMediaPlayerDelegate),
                "CLASS_EXTENSION_WORKER" => Some(Self::ClassExtensionWorker),
                "CLASS_SUBRESOURCE_FILTER" => Some(Self::ClassSubresourceFilter),
                "CLASS_UNFREEZABLE_FRAME" => Some(Self::ClassUnfreezableFrame),
                _ => None,
            }
        }
    }
}
/// Details about Chrome message pump events
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeMessagePump {
    /// True if there are sent messages in the queue.
    #[prost(bool, optional, tag = "1")]
    pub sent_messages_in_queue: ::core::option::Option<bool>,
    /// Interned SourceLocation of IO handler that MessagePumpForIO is about to
    /// invoke.
    #[prost(uint64, optional, tag = "2")]
    pub io_handler_location_iid: ::core::option::Option<u64>,
}
/// Contains information to identify mojo handling events. The trace events in
/// mojo are common for all mojo interfaces and this information is used to
/// identify who is the caller or callee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeMojoEventInfo {
    /// Contains the interface name or the file name of the creator of a mojo
    /// handle watcher, recorded when an event if notified to the watcher. The code
    /// that runs within the track event belongs to the interface.
    #[prost(string, optional, tag = "1")]
    pub watcher_notify_interface_tag: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// The hash of the IPC message that is being handled.
    #[prost(uint32, optional, tag = "2")]
    pub ipc_hash: ::core::option::Option<u32>,
    /// A static string representing the mojo interface name of the message that is
    /// being handled.
    #[prost(string, optional, tag = "3")]
    pub mojo_interface_tag: ::core::option::Option<::prost::alloc::string::String>,
    /// Refers to an interned UnsymbolizedSourceLocation.
    /// The UnsymbolizedSourceLocation contains the interface method that's being
    /// handled, represented as a native symbol.
    /// The native symbol can be symbolized after the trace is recorded.
    /// Not using a symbolized source location for official Chromium builds to
    /// reduce binary size - emitting file/function names as strings into the
    /// trace requires storing them in the binary, which causes a significant
    /// binary size bloat for Chromium.
    #[prost(uint64, optional, tag = "4")]
    pub mojo_interface_method_iid: ::core::option::Option<u64>,
    /// Indicate whether this is a message or reply.
    #[prost(bool, optional, tag = "5")]
    pub is_reply: ::core::option::Option<bool>,
    /// The payload size of the message being sent through mojo messages.
    #[prost(uint64, optional, tag = "6")]
    pub payload_size: ::core::option::Option<u64>,
    /// Represents the size of the message. Includes all headers and user payload.
    #[prost(uint64, optional, tag = "7")]
    pub data_num_bytes: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeRendererSchedulerState {
    #[prost(enumeration = "ChromeRailMode", optional, tag = "1")]
    pub rail_mode: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub is_backgrounded: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub is_hidden: ::core::option::Option<bool>,
}
/// RAIL Mode is an indication of the kind of work that a Renderer is currently
/// performing which is in turn used to prioritise work accordingly.
/// A fuller description of these modes can be found <https://web.dev/rail/>
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChromeRailMode {
    RailModeNone = 0,
    RailModeResponse = 1,
    RailModeAnimation = 2,
    RailModeIdle = 3,
    RailModeLoad = 4,
}
impl ChromeRailMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RailModeNone => "RAIL_MODE_NONE",
            Self::RailModeResponse => "RAIL_MODE_RESPONSE",
            Self::RailModeAnimation => "RAIL_MODE_ANIMATION",
            Self::RailModeIdle => "RAIL_MODE_IDLE",
            Self::RailModeLoad => "RAIL_MODE_LOAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RAIL_MODE_NONE" => Some(Self::RailModeNone),
            "RAIL_MODE_RESPONSE" => Some(Self::RailModeResponse),
            "RAIL_MODE_ANIMATION" => Some(Self::RailModeAnimation),
            "RAIL_MODE_IDLE" => Some(Self::RailModeIdle),
            "RAIL_MODE_LOAD" => Some(Self::RailModeLoad),
            _ => None,
        }
    }
}
/// Details about a UI interaction initiated by the user, such as opening or
/// closing a tab or a context menu.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeUserEvent {
    /// Name of the action, e.g. "NewTab", "ShowBookmarkManager", etc. (in
    /// Chrome, these are usually static strings known at compile time, or
    /// concatenations of multiple such static strings).
    #[prost(string, optional, tag = "1")]
    pub action: ::core::option::Option<::prost::alloc::string::String>,
    /// MD5 hash of the action string.
    #[prost(uint64, optional, tag = "2")]
    pub action_hash: ::core::option::Option<u64>,
}
/// Details about HWNDMessageHandler trace events.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeWindowHandleEventInfo {
    #[prost(uint32, optional, tag = "1")]
    pub dpi: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub message_id: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag = "3")]
    pub hwnd_ptr: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Screenshot {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub jpg_image: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Trace events emitted by client instrumentation library (TRACE_EVENT macros),
/// which describe activity on a track, such as a thread or asynchronous event
/// track. The track is specified using separate TrackDescriptor messages and
/// referred to via the track's UUID.
///
/// A simple TrackEvent packet specifies a timestamp, category, name and type:
/// ```protobuf
///    trace_packet {
///      timestamp: 1000
///      track_event {
///        categories: \["my_cat"\]
///        name: "my_event"
///        type: TYPE_INSTANT
///       }
///     }
/// ```
///
/// To associate an event with a custom track (e.g. a thread), the track is
/// defined in a separate packet and referred to from the TrackEvent by its UUID:
/// ```protobuf
///    trace_packet {
///      track_descriptor {
///        track_uuid: 1234
///        name: "my_track"
///
///        // Optionally, associate the track with a thread.
///        thread_descriptor {
///          pid: 10
///          tid: 10
///          ..
///        }
///      }
///    }
/// ```
///
/// A pair of TYPE_SLICE_BEGIN and _END events form a slice on the track:
///
/// ```protobuf
///    trace_packet {
///      timestamp: 1200
///      track_event {
///        track_uuid: 1234
///        categories: \["my_cat"\]
///        name: "my_slice"
///        type: TYPE_SLICE_BEGIN
///      }
///    }
///    trace_packet {
///      timestamp: 1400
///      track_event {
///        track_uuid: 1234
///        type: TYPE_SLICE_END
///      }
///    }
/// ```
/// TrackEvents also support optimizations to reduce data repetition and encoded
/// data size, e.g. through data interning (names, categories, ...) and delta
/// encoding of timestamps/counters. For details, see the InternedData message.
/// Further, default values for attributes of events on the same sequence (e.g.
/// their default track association) can be emitted as part of a
/// TrackEventDefaults message.
///
/// Next reserved id: 13 (up to 15). Next id: 52.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrackEvent {
    /// Names of categories of the event. In the client library, categories are a
    /// way to turn groups of individual events on or off.
    /// interned EventCategoryName.
    #[prost(uint64, repeated, packed = "false", tag = "3")]
    pub category_iids: ::prost::alloc::vec::Vec<u64>,
    /// non-interned variant.
    #[prost(string, repeated, tag = "22")]
    pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "track_event::Type", optional, tag = "9")]
    pub r#type: ::core::option::Option<i32>,
    /// Identifies the track of the event. The default value may be overridden
    /// using TrackEventDefaults, e.g., to specify the track of the TraceWriter's
    /// sequence (in most cases sequence = one thread). If no value is specified
    /// here or in TrackEventDefaults, the TrackEvent will be associated with an
    /// implicit trace-global track (uuid 0). See TrackDescriptor::uuid.
    #[prost(uint64, optional, tag = "11")]
    pub track_uuid: ::core::option::Option<u64>,
    /// To encode counter values more efficiently, we support attaching additional
    /// counter values to a TrackEvent of any type. All values will share the same
    /// timestamp specified in the TracePacket. The value at
    /// extra_counter_values\[N\] is for the counter track referenced by
    /// extra_counter_track_uuids\[N\].
    ///
    /// |extra_counter_track_uuids| may also be set via TrackEventDefaults. There
    /// should always be equal or more uuids than values. It is valid to set more
    /// uuids (e.g. via defaults) than values. If uuids are specified in
    /// TrackEventDefaults and a TrackEvent, the TrackEvent uuids override the
    /// default uuid list.
    ///
    /// For example, this allows snapshotting the thread time clock at each
    /// thread-track BEGIN and END event to capture the cpu time delta of a slice.
    #[prost(uint64, repeated, packed = "false", tag = "31")]
    pub extra_counter_track_uuids: ::prost::alloc::vec::Vec<u64>,
    #[prost(int64, repeated, packed = "false", tag = "12")]
    pub extra_counter_values: ::prost::alloc::vec::Vec<i64>,
    /// Counter snapshots using floating point instead of integer values.
    #[prost(uint64, repeated, packed = "false", tag = "45")]
    pub extra_double_counter_track_uuids: ::prost::alloc::vec::Vec<u64>,
    #[prost(double, repeated, packed = "false", tag = "46")]
    pub extra_double_counter_values: ::prost::alloc::vec::Vec<f64>,
    /// IDs of flows originating, passing through, or ending at this event.
    /// Flow IDs are global within a trace.
    ///
    /// A flow connects a sequence of TrackEvents within or across tracks, e.g.
    /// an input event may be handled on one thread but cause another event on
    /// a different thread - a flow between the two events can associate them.
    ///
    /// The direction of the flows between events is inferred from the events'
    /// timestamps. The earliest event with the same flow ID becomes the source
    /// of the flow. Any events thereafter are intermediate steps of the flow,
    /// until the flow terminates at the last event with the flow ID.
    ///
    /// Flows can also be explicitly terminated (see |terminating_flow_ids|), so
    /// that the same ID can later be reused for another flow.
    /// DEPRECATED. Only kept for backwards compatibility. Use |flow_ids|.
    #[deprecated]
    #[prost(uint64, repeated, packed = "false", tag = "36")]
    pub flow_ids_old: ::prost::alloc::vec::Vec<u64>,
    /// TODO(b/204341740): replace "flow_ids_old" with "flow_ids" to reduce memory
    /// consumption.
    #[prost(fixed64, repeated, packed = "false", tag = "47")]
    pub flow_ids: ::prost::alloc::vec::Vec<u64>,
    /// List of flow ids which should terminate on this event, otherwise same as
    /// |flow_ids|.
    /// Any one flow ID should be either listed as part of |flow_ids| OR
    /// |terminating_flow_ids|, not both.
    /// DEPRECATED. Only kept for backwards compatibility.  Use
    /// |terminating_flow_ids|.
    #[deprecated]
    #[prost(uint64, repeated, packed = "false", tag = "42")]
    pub terminating_flow_ids_old: ::prost::alloc::vec::Vec<u64>,
    /// TODO(b/204341740): replace "terminating_flow_ids_old" with
    /// "terminating_flow_ids" to reduce memory consumption.
    #[prost(fixed64, repeated, packed = "false", tag = "48")]
    pub terminating_flow_ids: ::prost::alloc::vec::Vec<u64>,
    /// Unstable key/value annotations shown in the trace viewer but not intended
    /// for metrics use.
    #[prost(message, repeated, tag = "4")]
    pub debug_annotations: ::prost::alloc::vec::Vec<DebugAnnotation>,
    /// Typed event arguments:
    #[prost(message, optional, tag = "5")]
    pub task_execution: ::core::option::Option<TaskExecution>,
    #[prost(message, optional, tag = "21")]
    pub log_message: ::core::option::Option<LogMessage>,
    #[prost(message, optional, tag = "24")]
    pub cc_scheduler_state: ::core::option::Option<ChromeCompositorSchedulerState>,
    #[prost(message, optional, tag = "25")]
    pub chrome_user_event: ::core::option::Option<ChromeUserEvent>,
    #[prost(message, optional, tag = "26")]
    pub chrome_keyed_service: ::core::option::Option<ChromeKeyedService>,
    #[prost(message, optional, tag = "27")]
    pub chrome_legacy_ipc: ::core::option::Option<ChromeLegacyIpc>,
    #[prost(message, optional, tag = "28")]
    pub chrome_histogram_sample: ::core::option::Option<ChromeHistogramSample>,
    #[prost(message, optional, tag = "29")]
    pub chrome_latency_info: ::core::option::Option<ChromeLatencyInfo>,
    #[prost(message, optional, tag = "32")]
    pub chrome_frame_reporter: ::core::option::Option<ChromeFrameReporter>,
    #[prost(message, optional, tag = "39")]
    pub chrome_application_state_info: ::core::option::Option<
        ChromeApplicationStateInfo,
    >,
    #[prost(message, optional, tag = "40")]
    pub chrome_renderer_scheduler_state: ::core::option::Option<
        ChromeRendererSchedulerState,
    >,
    #[prost(message, optional, tag = "41")]
    pub chrome_window_handle_event_info: ::core::option::Option<
        ChromeWindowHandleEventInfo,
    >,
    #[prost(message, optional, tag = "43")]
    pub chrome_content_settings_event_info: ::core::option::Option<
        ChromeContentSettingsEventInfo,
    >,
    #[prost(message, optional, tag = "49")]
    pub chrome_active_processes: ::core::option::Option<ChromeActiveProcesses>,
    #[prost(message, optional, tag = "50")]
    pub screenshot: ::core::option::Option<Screenshot>,
    #[prost(message, optional, tag = "35")]
    pub chrome_message_pump: ::core::option::Option<ChromeMessagePump>,
    #[prost(message, optional, tag = "38")]
    pub chrome_mojo_event_info: ::core::option::Option<ChromeMojoEventInfo>,
    #[prost(message, optional, tag = "6")]
    pub legacy_event: ::core::option::Option<track_event::LegacyEvent>,
    /// Optional name of the event for its display in trace viewer. May be left
    /// unspecified for events with typed arguments.
    ///
    /// Note that metrics should not rely on event names, as they are prone to
    /// changing. Instead, they should use typed arguments to identify the events
    /// they are interested in.
    #[prost(oneof = "track_event::NameField", tags = "10, 23")]
    pub name_field: ::core::option::Option<track_event::NameField>,
    /// A new value for a counter track. |track_uuid| should refer to a track with
    /// a CounterDescriptor, and |type| should be TYPE_COUNTER. For a more
    /// efficient encoding of counter values that are sampled at the beginning/end
    /// of a slice, see |extra_counter_values| and |extra_counter_track_uuids|.
    /// Counter values can optionally be encoded in as delta values (positive or
    /// negative) on each packet sequence (see CounterIncrementalBase).
    #[prost(oneof = "track_event::CounterValueField", tags = "30, 44")]
    pub counter_value_field: ::core::option::Option<track_event::CounterValueField>,
    /// This field is used only if the source location represents the function that
    /// executes during this event.
    #[prost(oneof = "track_event::SourceLocationField", tags = "33, 34")]
    pub source_location_field: ::core::option::Option<track_event::SourceLocationField>,
    /// Deprecated. Use the |timestamp| and |timestamp_clock_id| fields in
    /// TracePacket instead.
    ///
    /// Timestamp in microseconds (usually CLOCK_MONOTONIC).
    #[prost(oneof = "track_event::Timestamp", tags = "1, 16")]
    pub timestamp: ::core::option::Option<track_event::Timestamp>,
    /// Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
    /// encode thread time instead.
    ///
    /// CPU time for the current thread (e.g., CLOCK_THREAD_CPUTIME_ID) in
    /// microseconds.
    #[prost(oneof = "track_event::ThreadTime", tags = "2, 17")]
    pub thread_time: ::core::option::Option<track_event::ThreadTime>,
    /// Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
    /// encode thread instruction count instead.
    ///
    /// Value of the instruction counter for the current thread.
    #[prost(oneof = "track_event::ThreadInstructionCount", tags = "8, 20")]
    pub thread_instruction_count: ::core::option::Option<
        track_event::ThreadInstructionCount,
    >,
}
/// Nested message and enum types in `TrackEvent`.
pub mod track_event {
    /// Apart from {category, time, thread time, tid, pid}, other legacy trace
    /// event attributes are initially simply proxied for conversion to a JSON
    /// trace. We intend to gradually transition these attributes to similar native
    /// features in TrackEvent (e.g. async + flow events), or deprecate them
    /// without replacement where transition is unsuitable.
    ///
    /// Next reserved id: 16 (up to 16).
    /// Next id: 20.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LegacyEvent {
        /// Deprecated, use TrackEvent::name(_iid) instead.
        /// interned EventName.
        #[prost(uint64, optional, tag = "1")]
        pub name_iid: ::core::option::Option<u64>,
        #[prost(int32, optional, tag = "2")]
        pub phase: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "3")]
        pub duration_us: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "4")]
        pub thread_duration_us: ::core::option::Option<i64>,
        /// Elapsed retired instruction count during the event.
        #[prost(int64, optional, tag = "15")]
        pub thread_instruction_delta: ::core::option::Option<i64>,
        /// Additional optional scope for |id|.
        #[prost(string, optional, tag = "7")]
        pub id_scope: ::core::option::Option<::prost::alloc::string::String>,
        /// Consider the thread timestamps for async BEGIN/END event pairs as valid.
        #[prost(bool, optional, tag = "9")]
        pub use_async_tts: ::core::option::Option<bool>,
        /// Idenfifies a flow. Flow events with the same bind_id are connected.
        #[prost(uint64, optional, tag = "8")]
        pub bind_id: ::core::option::Option<u64>,
        /// Use the enclosing slice as binding point for a flow end event instead of
        /// the next slice. Flow start/step events always bind to the enclosing
        /// slice.
        #[prost(bool, optional, tag = "12")]
        pub bind_to_enclosing: ::core::option::Option<bool>,
        #[prost(enumeration = "legacy_event::FlowDirection", optional, tag = "13")]
        pub flow_direction: ::core::option::Option<i32>,
        #[prost(enumeration = "legacy_event::InstantEventScope", optional, tag = "14")]
        pub instant_event_scope: ::core::option::Option<i32>,
        /// Override the pid/tid if the writer needs to emit events on behalf of
        /// another process/thread. This should be the exception. Normally, the
        /// pid+tid from ThreadDescriptor is used.
        #[prost(int32, optional, tag = "18")]
        pub pid_override: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "19")]
        pub tid_override: ::core::option::Option<i32>,
        #[prost(oneof = "legacy_event::Id", tags = "6, 10, 11")]
        pub id: ::core::option::Option<legacy_event::Id>,
    }
    /// Nested message and enum types in `LegacyEvent`.
    pub mod legacy_event {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FlowDirection {
            FlowUnspecified = 0,
            FlowIn = 1,
            FlowOut = 2,
            FlowInout = 3,
        }
        impl FlowDirection {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::FlowUnspecified => "FLOW_UNSPECIFIED",
                    Self::FlowIn => "FLOW_IN",
                    Self::FlowOut => "FLOW_OUT",
                    Self::FlowInout => "FLOW_INOUT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FLOW_UNSPECIFIED" => Some(Self::FlowUnspecified),
                    "FLOW_IN" => Some(Self::FlowIn),
                    "FLOW_OUT" => Some(Self::FlowOut),
                    "FLOW_INOUT" => Some(Self::FlowInout),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum InstantEventScope {
            ScopeUnspecified = 0,
            ScopeGlobal = 1,
            ScopeProcess = 2,
            ScopeThread = 3,
        }
        impl InstantEventScope {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::ScopeUnspecified => "SCOPE_UNSPECIFIED",
                    Self::ScopeGlobal => "SCOPE_GLOBAL",
                    Self::ScopeProcess => "SCOPE_PROCESS",
                    Self::ScopeThread => "SCOPE_THREAD",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SCOPE_UNSPECIFIED" => Some(Self::ScopeUnspecified),
                    "SCOPE_GLOBAL" => Some(Self::ScopeGlobal),
                    "SCOPE_PROCESS" => Some(Self::ScopeProcess),
                    "SCOPE_THREAD" => Some(Self::ScopeThread),
                    _ => None,
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Id {
            #[prost(uint64, tag = "6")]
            UnscopedId(u64),
            #[prost(uint64, tag = "10")]
            LocalId(u64),
            #[prost(uint64, tag = "11")]
            GlobalId(u64),
        }
    }
    /// Type of the TrackEvent (required if |phase| in LegacyEvent is not set).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        /// Slice events are events that have a begin and end timestamp, i.e. a
        /// duration. They can be nested similar to a callstack: If, on the same
        /// track, event B begins after event A, but before A ends, B is a child
        /// event of A and will be drawn as a nested event underneath A in the UI.
        /// Note that child events should always end before their parents (e.g. B
        /// before A).
        ///
        /// Each slice event is formed by a pair of BEGIN + END events. The END event
        /// does not need to repeat any TrackEvent fields it has in common with its
        /// corresponding BEGIN event. Arguments and debug annotations of the BEGIN +
        /// END pair will be merged during trace import.
        ///
        /// Note that we deliberately chose not to support COMPLETE events (which
        /// would specify a duration directly) since clients would need to delay
        /// writing them until the slice is completed, which can result in reordered
        /// events in the trace and loss of unfinished events at the end of a trace.
        SliceBegin = 1,
        SliceEnd = 2,
        /// Instant events are nestable events without duration. They can be children
        /// of slice events on the same track.
        Instant = 3,
        /// Event that provides a value for a counter track. |track_uuid| should
        /// refer to a counter track and |counter_value| set to the new value. Note
        /// that most other TrackEvent fields (e.g. categories, name, ..) are not
        /// supported for TYPE_COUNTER events. See also CounterDescriptor.
        Counter = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::SliceBegin => "TYPE_SLICE_BEGIN",
                Self::SliceEnd => "TYPE_SLICE_END",
                Self::Instant => "TYPE_INSTANT",
                Self::Counter => "TYPE_COUNTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TYPE_SLICE_BEGIN" => Some(Self::SliceBegin),
                "TYPE_SLICE_END" => Some(Self::SliceEnd),
                "TYPE_INSTANT" => Some(Self::Instant),
                "TYPE_COUNTER" => Some(Self::Counter),
                _ => None,
            }
        }
    }
    /// Optional name of the event for its display in trace viewer. May be left
    /// unspecified for events with typed arguments.
    ///
    /// Note that metrics should not rely on event names, as they are prone to
    /// changing. Instead, they should use typed arguments to identify the events
    /// they are interested in.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum NameField {
        /// interned EventName.
        #[prost(uint64, tag = "10")]
        NameIid(u64),
        /// non-interned variant.
        #[prost(string, tag = "23")]
        Name(::prost::alloc::string::String),
    }
    /// A new value for a counter track. |track_uuid| should refer to a track with
    /// a CounterDescriptor, and |type| should be TYPE_COUNTER. For a more
    /// efficient encoding of counter values that are sampled at the beginning/end
    /// of a slice, see |extra_counter_values| and |extra_counter_track_uuids|.
    /// Counter values can optionally be encoded in as delta values (positive or
    /// negative) on each packet sequence (see CounterIncrementalBase).
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum CounterValueField {
        #[prost(int64, tag = "30")]
        CounterValue(i64),
        #[prost(double, tag = "44")]
        DoubleCounterValue(f64),
    }
    /// This field is used only if the source location represents the function that
    /// executes during this event.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SourceLocationField {
        /// Non-interned field.
        #[prost(message, tag = "33")]
        SourceLocation(super::SourceLocation),
        /// Interned field.
        #[prost(uint64, tag = "34")]
        SourceLocationIid(u64),
    }
    /// Deprecated. Use the |timestamp| and |timestamp_clock_id| fields in
    /// TracePacket instead.
    ///
    /// Timestamp in microseconds (usually CLOCK_MONOTONIC).
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Timestamp {
        /// Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
        /// calculate the absolute timestamp value, sum up all delta values of the
        /// preceding TrackEvents since the last ThreadDescriptor and add the sum to
        /// the |reference_timestamp| in ThreadDescriptor. This value should always
        /// be positive.
        #[prost(int64, tag = "1")]
        TimestampDeltaUs(i64),
        /// Absolute value (e.g. a manually specified timestamp in the macro).
        /// This is a one-off value that does not affect delta timestamp computation
        /// in subsequent TrackEvents.
        #[prost(int64, tag = "16")]
        TimestampAbsoluteUs(i64),
    }
    /// Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
    /// encode thread time instead.
    ///
    /// CPU time for the current thread (e.g., CLOCK_THREAD_CPUTIME_ID) in
    /// microseconds.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ThreadTime {
        /// Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
        /// calculate the absolute timestamp value, sum up all delta values of the
        /// preceding TrackEvents since the last ThreadDescriptor and add the sum to
        /// the |reference_timestamp| in ThreadDescriptor. This value should always
        /// be positive.
        #[prost(int64, tag = "2")]
        ThreadTimeDeltaUs(i64),
        /// This is a one-off absolute value that does not affect delta timestamp
        /// computation in subsequent TrackEvents.
        #[prost(int64, tag = "17")]
        ThreadTimeAbsoluteUs(i64),
    }
    /// Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
    /// encode thread instruction count instead.
    ///
    /// Value of the instruction counter for the current thread.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ThreadInstructionCount {
        /// Same encoding as |thread_time| field above.
        #[prost(int64, tag = "8")]
        ThreadInstructionCountDelta(i64),
        #[prost(int64, tag = "20")]
        ThreadInstructionCountAbsolute(i64),
    }
}
/// Default values for fields of all TrackEvents on the same packet sequence.
/// Should be emitted as part of TracePacketDefaults whenever incremental state
/// is cleared. It's defined here because field IDs should match those of the
/// corresponding fields in TrackEvent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrackEventDefaults {
    #[prost(uint64, optional, tag = "11")]
    pub track_uuid: ::core::option::Option<u64>,
    #[prost(uint64, repeated, packed = "false", tag = "31")]
    pub extra_counter_track_uuids: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, repeated, packed = "false", tag = "45")]
    pub extra_double_counter_track_uuids: ::prost::alloc::vec::Vec<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventCategory {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventName {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Minimal TracePacket with only the fields used by rfr-convert
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TracePacket {
    /// Timestamp of the TracePacket.
    /// Unit is nanoseconds. The clock source is specified by timestamp_clock_id.
    #[prost(uint64, optional, tag = "8")]
    pub timestamp: ::core::option::Option<u64>,
    /// Specifies the ID of the clock used for the TracePacket |timestamp|. Can be
    /// one of the built-in clock IDs (e.g. REALTIME, MONOTONIC) or a producer-
    /// specific ID.
    #[prost(uint32, optional, tag = "58")]
    pub timestamp_clock_id: ::core::option::Option<u32>,
    /// The |trusted_packet_sequence_id| is a monotonically increasing id that is
    /// unique per trace writer.
    #[prost(uint32, optional, tag = "10")]
    pub trusted_packet_sequence_id: ::core::option::Option<u32>,
    /// Packets emitted by the trace writer may have the following flags:
    /// - SEQ_NEEDS_INCREMENTAL_STATE (1): indicates that the packet requires
    ///    incremental state to be understood.
    /// - SEQ_INCREMENTAL_STATE_CLEARED (2): indicates that the writer has cleared
    ///    its incremental state (e.g. on session restart).
    #[prost(uint32, optional, tag = "13")]
    pub sequence_flags: ::core::option::Option<u32>,
    /// Describes a track for TrackEvents.
    #[prost(message, optional, tag = "60")]
    pub track_descriptor: ::core::option::Option<TrackDescriptor>,
    /// Event on a track with a category and name.
    #[prost(message, optional, tag = "11")]
    pub track_event: ::core::option::Option<TrackEvent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trace {
    #[prost(message, repeated, tag = "1")]
    pub packet: ::prost::alloc::vec::Vec<TracePacket>,
}
